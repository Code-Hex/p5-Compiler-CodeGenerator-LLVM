; ModuleID = 'gen/runtime_api.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.7.0"

%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sbuf = type { i8*, i32 }
%struct.__sFILEX = type opaque
%union.UnionType = type { double }
%struct._Hash = type { i32, %union.UnionType*, %struct._String**, i64 }
%struct._String = type { i32, i8*, i64, i64 }
%struct._Array = type { i32, %union.UnionType*, i64 }
%struct._Object = type { i32, %union.UnionType, i8*, i8*, i8*, i8*, i8*, i8* }
%struct._BlessedObject = type { i32, %union.UnionType, %struct._Hash*, i8* }
%struct._Undef = type { i32 }
%struct._HashRef = type { i32, %union.UnionType }
%struct._CodeRef = type { i32, i64 (%struct._Array*)* }
%struct._ArrayRef = type { i32, %union.UnionType }

@__func__._abs = private unnamed_addr constant [5 x i8] c"_abs\00", align 1
@.str = private unnamed_addr constant [18 x i8] c"gen/runtime_api.c\00", align 1
@.str1 = private unnamed_addr constant [36 x i8] c"0 && \22Type Error!!! abs's argument\22\00", align 1
@__func__._int = private unnamed_addr constant [5 x i8] c"_int\00", align 1
@__func__._sin = private unnamed_addr constant [5 x i8] c"_sin\00", align 1
@__func__._cos = private unnamed_addr constant [5 x i8] c"_cos\00", align 1
@__stdoutp = external global %struct.__sFILE*
@.str2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str3 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str4 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str5 = private unnamed_addr constant [10 x i8] c"ARRAY(%p)\00", align 1
@.str6 = private unnamed_addr constant [9 x i8] c"HASH(%p)\00", align 1
@.str7 = private unnamed_addr constant [9 x i8] c"CODE(%p)\00", align 1
@.str8 = private unnamed_addr constant [12 x i8] c"%s=HASH(%p)\00", align 1
@.str9 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@__stderrp = external global %struct.__sFILE*
@.str10 = private unnamed_addr constant [26 x i8] c"===== debug_print ======\0A\00", align 1
@.str11 = private unnamed_addr constant [15 x i8] c"=============\0A\00", align 1
@__func__.shift = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str12 = private unnamed_addr constant [21 x i8] c"0 && \22Type Error!\5Cn\22\00", align 1
@.str13 = private unnamed_addr constant [30 x i8] c"fetch from function argument\0A\00", align 1
@.str14 = private unnamed_addr constant [27 x i8] c"Type Error!: near by push\0A\00", align 1
@__func__.push = private unnamed_addr constant [5 x i8] c"push\00", align 1
@.str15 = private unnamed_addr constant [34 x i8] c"ERROR!!: cannot allocated memory\0A\00", align 1
@undef = common global %union.UnionType zeroinitializer, align 8
@base_hash_table = common global %union.UnionType* null, align 8
@pkg_map = common global %struct._Hash* null, align 8
@.str16 = private unnamed_addr constant [54 x i8] c"ERROR!: bless function must be required two argument\0A\00", align 1
@__func__.bless = private unnamed_addr constant [6 x i8] c"bless\00", align 1
@__func__.get_method_by_name = private unnamed_addr constant [19 x i8] c"get_method_by_name\00", align 1
@.str17 = private unnamed_addr constant [15 x i8] c"type = [%llu]\0A\00", align 1
@__func__.dynamic_blessed_object_cast_code = private unnamed_addr constant [33 x i8] c"dynamic_blessed_object_cast_code\00", align 1
@u = common global %union.UnionType zeroinitializer, align 8

; Function Attrs: nounwind ssp uwtable
define i64 @_sqrt(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %arg = alloca %union.UnionType, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %0, i32 0, i32 1
  %1 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %1, i64 0
  %2 = bitcast %union.UnionType* %arg to i8*
  %3 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 8, i32 8, i1 false)
  %o = bitcast %union.UnionType* %arg to i8**
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %o2 = bitcast %union.UnionType* %arg to i8**
  %6 = load i8** %o2, align 8
  %7 = ptrtoint i8* %6 to i64
  %and3 = and i64 %7, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  %cmp4 = icmp eq i64 %mul, 7
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %o6 = bitcast %union.UnionType* %arg to i8**
  %8 = load i8** %o6, align 8
  %9 = ptrtoint i8* %8 to i64
  %xor = xor i64 %9, -2533274790395904
  %10 = inttoptr i64 %xor to %struct._Object*
  %v = getelementptr inbounds %struct._Object* %10, i32 0, i32 1
  %11 = bitcast %union.UnionType* %arg to i8*
  %12 = bitcast %union.UnionType* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %13 = bitcast %union.UnionType* %arg to i8*
  %14 = bitcast %union.UnionType* %arg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %d = bitcast %union.UnionType* %arg to double*
  %15 = load double* %d, align 8
  %call = call double @sqrt(double %15) #5
  %d7 = bitcast %union.UnionType* %ret to double*
  store double %call, double* %d7, align 8
  %16 = bitcast %union.UnionType* %retval to i8*
  %17 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %17, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %18 = bitcast double* %coerce.dive to i64*
  %19 = load i64* %18, align 1
  ret i64 %19
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) #1

; Function Attrs: nounwind readnone
declare double @sqrt(double) #2

; Function Attrs: nounwind ssp uwtable
define i64 @_abs(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %arg = alloca %union.UnionType, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %0, i32 0, i32 1
  %1 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %1, i64 0
  %2 = bitcast %union.UnionType* %arg to i8*
  %3 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 8, i32 8, i1 false)
  %o = bitcast %union.UnionType* %arg to i8**
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %o2 = bitcast %union.UnionType* %arg to i8**
  %6 = load i8** %o2, align 8
  %7 = ptrtoint i8* %6 to i64
  %and3 = and i64 %7, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry
  %o4 = bitcast %union.UnionType* %arg to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %call = call i32 @abs(i32 %conv5) #5
  %conv6 = zext i32 %call to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %10 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %10, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %d = bitcast %union.UnionType* %arg to double*
  %11 = load double* %d, align 8
  %call10 = call double @fabs(double %11) #5
  %d11 = bitcast %union.UnionType* %ret to double*
  store double %call10, double* %d11, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([5 x i8]* @__func__._abs, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 27, i8* getelementptr inbounds ([36 x i8]* @.str1, i32 0, i32 0)) #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb9, %sw.bb
  %12 = bitcast %union.UnionType* %retval to i8*
  %13 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %14 = bitcast double* %coerce.dive to i64*
  %15 = load i64* %14, align 1
  ret i64 %15
}

; Function Attrs: nounwind readnone
declare i32 @abs(i32) #2

; Function Attrs: nounwind readnone
declare double @fabs(double) #2

; Function Attrs: noreturn
declare void @__assert_rtn(i8*, i8*, i32, i8*) #3

; Function Attrs: nounwind ssp uwtable
define i64 @_int(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %arg = alloca %union.UnionType, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %0, i32 0, i32 1
  %1 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %1, i64 0
  %2 = bitcast %union.UnionType* %arg to i8*
  %3 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 8, i32 8, i1 false)
  %o = bitcast %union.UnionType* %arg to i8**
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %o2 = bitcast %union.UnionType* %arg to i8**
  %6 = load i8** %o2, align 8
  %7 = ptrtoint i8* %6 to i64
  %and3 = and i64 %7, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %o4 = bitcast %union.UnionType* %arg to i8**
  %8 = load i8** %o4, align 8
  %o5 = bitcast %union.UnionType* %ret to i8**
  store i8* %8, i8** %o5, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %d = bitcast %union.UnionType* %arg to double*
  %9 = load double* %d, align 8
  %conv7 = fptosi double %9 to i32
  %conv8 = zext i32 %conv7 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %10 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %10, i8** %o10, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([5 x i8]* @__func__._int, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 45, i8* getelementptr inbounds ([36 x i8]* @.str1, i32 0, i32 0)) #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb6, %sw.bb
  %11 = bitcast %union.UnionType* %retval to i8*
  %12 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %13 = bitcast double* %coerce.dive to i64*
  %14 = load i64* %13, align 1
  ret i64 %14
}

; Function Attrs: nounwind ssp uwtable
define i64 @_rand(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %random = alloca double, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %call = call i32 @rand()
  %conv = sitofp i32 %call to double
  %div = fdiv double %conv, 0x41DFFFFFFFC00000
  store double %div, double* %random, align 8
  %0 = load double* %random, align 8
  %d = bitcast %union.UnionType* %ret to double*
  store double %0, double* %d, align 8
  %1 = bitcast %union.UnionType* %retval to i8*
  %2 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %3 = bitcast double* %coerce.dive to i64*
  %4 = load i64* %3, align 1
  ret i64 %4
}

declare i32 @rand() #4

; Function Attrs: nounwind ssp uwtable
define i64 @_sin(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %arg = alloca %union.UnionType, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %0, i32 0, i32 1
  %1 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %1, i64 0
  %2 = bitcast %union.UnionType* %arg to i8*
  %3 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 8, i32 8, i1 false)
  %o = bitcast %union.UnionType* %arg to i8**
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %o2 = bitcast %union.UnionType* %arg to i8**
  %6 = load i8** %o2, align 8
  %7 = ptrtoint i8* %6 to i64
  %and3 = and i64 %7, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %o4 = bitcast %union.UnionType* %arg to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %call = call double @sin(double %conv5) #5
  %d = bitcast %union.UnionType* %ret to double*
  store double %call, double* %d, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %d7 = bitcast %union.UnionType* %arg to double*
  %10 = load double* %d7, align 8
  %call8 = call double @sin(double %10) #5
  %d9 = bitcast %union.UnionType* %ret to double*
  store double %call8, double* %d9, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([5 x i8]* @__func__._sin, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 71, i8* getelementptr inbounds ([36 x i8]* @.str1, i32 0, i32 0)) #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb6, %sw.bb
  %11 = bitcast %union.UnionType* %retval to i8*
  %12 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %13 = bitcast double* %coerce.dive to i64*
  %14 = load i64* %13, align 1
  ret i64 %14
}

; Function Attrs: nounwind readnone
declare double @sin(double) #2

; Function Attrs: nounwind ssp uwtable
define i64 @_cos(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %arg = alloca %union.UnionType, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %0, i32 0, i32 1
  %1 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %1, i64 0
  %2 = bitcast %union.UnionType* %arg to i8*
  %3 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 8, i32 8, i1 false)
  %o = bitcast %union.UnionType* %arg to i8**
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %o2 = bitcast %union.UnionType* %arg to i8**
  %6 = load i8** %o2, align 8
  %7 = ptrtoint i8* %6 to i64
  %and3 = and i64 %7, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %o4 = bitcast %union.UnionType* %arg to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %call = call double @cos(double %conv5) #5
  %d = bitcast %union.UnionType* %ret to double*
  store double %call, double* %d, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %d7 = bitcast %union.UnionType* %arg to double*
  %10 = load double* %d7, align 8
  %call8 = call double @cos(double %10) #5
  %d9 = bitcast %union.UnionType* %ret to double*
  store double %call8, double* %d9, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call void @__assert_rtn(i8* getelementptr inbounds ([5 x i8]* @__func__._cos, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 89, i8* getelementptr inbounds ([36 x i8]* @.str1, i32 0, i32 0)) #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb6, %sw.bb
  %11 = bitcast %union.UnionType* %retval to i8*
  %12 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %13 = bitcast double* %coerce.dive to i64*
  %14 = load i64* %13, align 1
  ret i64 %14
}

; Function Attrs: nounwind readnone
declare double @cos(double) #2

; Function Attrs: nounwind ssp uwtable
define i64 @_atan2(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %arg1 = alloca %union.UnionType, align 8
  %arg2 = alloca %union.UnionType, align 8
  %d1 = alloca double, align 8
  %d2 = alloca double, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %0, i32 0, i32 1
  %1 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %1, i64 0
  %2 = bitcast %union.UnionType* %arg1 to i8*
  %3 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 8, i32 8, i1 false)
  %4 = load %struct._Array** %args.addr, align 8
  %list1 = getelementptr inbounds %struct._Array* %4, i32 0, i32 1
  %5 = load %union.UnionType** %list1, align 8
  %arrayidx2 = getelementptr inbounds %union.UnionType* %5, i64 1
  %6 = bitcast %union.UnionType* %arg2 to i8*
  %7 = bitcast %union.UnionType* %arrayidx2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 8, i32 8, i1 false)
  %o = bitcast %union.UnionType* %arg1 to i8**
  %8 = load i8** %o, align 8
  %9 = ptrtoint i8* %8 to i64
  %and = and i64 %9, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv3 = sext i32 %conv to i64
  %o4 = bitcast %union.UnionType* %arg1 to i8**
  %10 = load i8** %o4, align 8
  %11 = ptrtoint i8* %10 to i64
  %and5 = and i64 %11, 4222124650659840
  %shr = lshr i64 %and5, 48
  %mul = mul i64 %conv3, %shr
  %cmp6 = icmp eq i64 %mul, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %o8 = bitcast %union.UnionType* %arg1 to i8**
  %12 = load i8** %o8, align 8
  %13 = ptrtoint i8* %12 to i64
  %conv9 = sitofp i64 %13 to double
  br label %cond.end

cond.false:                                       ; preds = %entry
  %d = bitcast %union.UnionType* %arg1 to double*
  %14 = load double* %d, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %conv9, %cond.true ], [ %14, %cond.false ]
  store double %cond, double* %d1, align 8
  %o10 = bitcast %union.UnionType* %arg2 to i8**
  %15 = load i8** %o10, align 8
  %16 = ptrtoint i8* %15 to i64
  %and11 = and i64 %16, -4503599627370496
  %cmp12 = icmp eq i64 %and11, -4503599627370496
  %conv13 = zext i1 %cmp12 to i32
  %conv14 = sext i32 %conv13 to i64
  %o15 = bitcast %union.UnionType* %arg2 to i8**
  %17 = load i8** %o15, align 8
  %18 = ptrtoint i8* %17 to i64
  %and16 = and i64 %18, 4222124650659840
  %shr17 = lshr i64 %and16, 48
  %mul18 = mul i64 %conv14, %shr17
  %cmp19 = icmp eq i64 %mul18, 1
  br i1 %cmp19, label %cond.true21, label %cond.false24

cond.true21:                                      ; preds = %cond.end
  %o22 = bitcast %union.UnionType* %arg2 to i8**
  %19 = load i8** %o22, align 8
  %20 = ptrtoint i8* %19 to i64
  %conv23 = sitofp i64 %20 to double
  br label %cond.end26

cond.false24:                                     ; preds = %cond.end
  %d25 = bitcast %union.UnionType* %arg2 to double*
  %21 = load double* %d25, align 8
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false24, %cond.true21
  %cond27 = phi double [ %conv23, %cond.true21 ], [ %21, %cond.false24 ]
  store double %cond27, double* %d2, align 8
  %22 = load double* %d1, align 8
  %23 = load double* %d2, align 8
  %call = call double @atan2(double %22, double %23) #5
  %d28 = bitcast %union.UnionType* %ret to double*
  store double %call, double* %d28, align 8
  %24 = bitcast %union.UnionType* %retval to i8*
  %25 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %25, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %26 = bitcast double* %coerce.dive to i64*
  %27 = load i64* %26, align 1
  ret i64 %27
}

; Function Attrs: nounwind readnone
declare double @atan2(double, double) #2

; Function Attrs: nounwind ssp uwtable
define void @print_object(i64 %_o.coerce) #0 {
entry:
  %_o = alloca %union.UnionType, align 8
  %o = alloca i8*, align 8
  %coerce = alloca %union.UnionType, align 8
  %object = alloca %struct._Object*, align 8
  %coerce.dive = getelementptr %union.UnionType* %_o, i32 0, i32 0
  %0 = bitcast double* %coerce.dive to i64*
  store i64 %_o.coerce, i64* %0, align 1
  %o1 = bitcast %union.UnionType* %_o to i8**
  %1 = load i8** %o1, align 8
  store i8* %1, i8** %o, align 8
  %2 = load i8** %o, align 8
  %3 = ptrtoint i8* %2 to i64
  %and = and i64 %3, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv2 = sext i32 %conv to i64
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv2, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb4
    i64 2, label %sw.bb6
    i64 3, label %sw.bb8
    i64 4, label %sw.bb12
    i64 5, label %sw.bb14
    i64 6, label %sw.bb16
    i64 9, label %sw.bb18
    i64 7, label %sw.bb20
    i64 8, label %sw.bb23
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %struct.__sFILE** @__stdoutp, align 8
  %7 = load i8** %o, align 8
  %8 = ptrtoint i8* %7 to i64
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %6, i8* getelementptr inbounds ([3 x i8]* @.str2, i32 0, i32 0), i64 %8)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %9 = load %struct.__sFILE** @__stdoutp, align 8
  %d = bitcast %union.UnionType* %_o to double*
  %10 = load double* %d, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([3 x i8]* @.str3, i32 0, i32 0), double %10)
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %11 = load %struct.__sFILE** @__stdoutp, align 8
  %12 = load i8** %o, align 8
  %13 = ptrtoint i8* %12 to i64
  %xor = xor i64 %13, -3940649673949184
  %14 = inttoptr i64 %xor to %struct._String*
  %s = getelementptr inbounds %struct._String* %14, i32 0, i32 1
  %15 = load i8** %s, align 8
  %call7 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %11, i8* getelementptr inbounds ([3 x i8]* @.str4, i32 0, i32 0), i8* %15)
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %16 = load i8** %o, align 8
  %17 = ptrtoint i8* %16 to i64
  %xor9 = xor i64 %17, -3659174697238528
  %18 = inttoptr i64 %xor9 to %struct._Array*
  %call10 = call i64 @print(%struct._Array* %18)
  %coerce.dive11 = getelementptr %union.UnionType* %coerce, i32 0, i32 0
  %19 = bitcast double* %coerce.dive11 to i64*
  store i64 %call10, i64* %19, align 1
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  %20 = load %struct.__sFILE** @__stdoutp, align 8
  %21 = load i8** %o, align 8
  %call13 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %20, i8* getelementptr inbounds ([10 x i8]* @.str5, i32 0, i32 0), i8* %21)
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  %22 = load i8** %o, align 8
  %23 = ptrtoint i8* %22 to i64
  %xor15 = xor i64 %23, -3096224743817216
  %24 = inttoptr i64 %xor15 to %struct._Hash*
  call void @print_hash(%struct._Hash* %24)
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry
  %25 = load %struct.__sFILE** @__stdoutp, align 8
  %26 = load i8** %o, align 8
  %call17 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %25, i8* getelementptr inbounds ([9 x i8]* @.str6, i32 0, i32 0), i8* %26)
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  %27 = load %struct.__sFILE** @__stdoutp, align 8
  %28 = load i8** %o, align 8
  %call19 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %27, i8* getelementptr inbounds ([9 x i8]* @.str7, i32 0, i32 0), i8* %28)
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %29 = load i8** %o, align 8
  %30 = ptrtoint i8* %29 to i64
  %xor21 = xor i64 %30, -2533274790395904
  %31 = inttoptr i64 %xor21 to %struct._Object*
  store %struct._Object* %31, %struct._Object** %object, align 8
  %32 = load %struct._Object** %object, align 8
  %v = getelementptr inbounds %struct._Object* %32, i32 0, i32 1
  %coerce.dive22 = getelementptr %union.UnionType* %v, i32 0, i32 0
  %33 = bitcast double* %coerce.dive22 to i64*
  %34 = load i64* %33, align 1
  call void @print_object(i64 %34)
  br label %sw.epilog

sw.bb23:                                          ; preds = %entry
  %35 = load %struct.__sFILE** @__stdoutp, align 8
  %36 = load i8** %o, align 8
  %37 = ptrtoint i8* %36 to i64
  %xor24 = xor i64 %37, -2251799813685248
  %38 = inttoptr i64 %xor24 to %struct._BlessedObject*
  %pkg_name = getelementptr inbounds %struct._BlessedObject* %38, i32 0, i32 3
  %39 = load i8** %pkg_name, align 8
  %40 = load i8** %o, align 8
  %call25 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %35, i8* getelementptr inbounds ([12 x i8]* @.str8, i32 0, i32 0), i8* %39, i8* %40)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb23, %sw.bb20, %sw.bb18, %sw.bb16, %sw.bb14, %sw.bb12, %sw.bb8, %sw.bb6, %sw.bb4, %sw.bb
  ret void
}

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #4

; Function Attrs: nounwind ssp uwtable
define i64 @print(%struct._Array* %array) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %array.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %size = alloca i64, align 8
  %i = alloca i64, align 8
  store %struct._Array* %array, %struct._Array** %array.addr, align 8
  %0 = load %struct._Array** %array.addr, align 8
  %size1 = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size1, align 8
  store i64 %1, i64* %size, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64* %i, align 8
  %3 = load i64* %size, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64* %i, align 8
  %5 = load %struct._Array** %array.addr, align 8
  %list = getelementptr inbounds %struct._Array* %5, i32 0, i32 1
  %6 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %6, i64 %4
  %coerce.dive = getelementptr %union.UnionType* %arrayidx, i32 0, i32 0
  %7 = bitcast double* %coerce.dive to i64*
  %8 = load i64* %7, align 1
  call void @print_object(i64 %8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64* %i, align 8
  %inc = add i64 %9, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %o = bitcast %union.UnionType* %ret to i8**
  store i8* inttoptr (i64 -4222124650659840 to i8*), i8** %o, align 8
  %10 = bitcast %union.UnionType* %retval to i8*
  %11 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false)
  %coerce.dive2 = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %12 = bitcast double* %coerce.dive2 to i64*
  %13 = load i64* %12, align 1
  ret i64 %13
}

; Function Attrs: nounwind ssp uwtable
define void @print_hash(%struct._Hash* %hash) #0 {
entry:
  %hash.addr = alloca %struct._Hash*, align 8
  %key_n = alloca i64, align 8
  %i = alloca i64, align 8
  %key = alloca %struct._String*, align 8
  store %struct._Hash* %hash, %struct._Hash** %hash.addr, align 8
  %0 = load %struct._Hash** %hash.addr, align 8
  %size = getelementptr inbounds %struct._Hash* %0, i32 0, i32 3
  %1 = load i64* %size, align 8
  store i64 %1, i64* %key_n, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64* %i, align 8
  %3 = load i64* %key_n, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64* %i, align 8
  %5 = load %struct._Hash** %hash.addr, align 8
  %keys = getelementptr inbounds %struct._Hash* %5, i32 0, i32 2
  %6 = load %struct._String*** %keys, align 8
  %arrayidx = getelementptr inbounds %struct._String** %6, i64 %4
  %7 = load %struct._String** %arrayidx, align 8
  store %struct._String* %7, %struct._String** %key, align 8
  %8 = load %struct.__sFILE** @__stdoutp, align 8
  %9 = load %struct._String** %key, align 8
  %s = getelementptr inbounds %struct._String* %9, i32 0, i32 1
  %10 = load i8** %s, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %8, i8* getelementptr inbounds ([3 x i8]* @.str4, i32 0, i32 0), i8* %10)
  %11 = load %struct._String** %key, align 8
  %hash1 = getelementptr inbounds %struct._String* %11, i32 0, i32 3
  %12 = load i64* %hash1, align 8
  %13 = load %struct._Hash** %hash.addr, align 8
  %table = getelementptr inbounds %struct._Hash* %13, i32 0, i32 1
  %14 = load %union.UnionType** %table, align 8
  %arrayidx2 = getelementptr inbounds %union.UnionType* %14, i64 %12
  %coerce.dive = getelementptr %union.UnionType* %arrayidx2, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  call void @print_object(i64 %16)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i64* %i, align 8
  %inc = add i64 %17, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 @say(%struct._Array* %array) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %array.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %coerce = alloca %union.UnionType, align 8
  store %struct._Array* %array, %struct._Array** %array.addr, align 8
  %0 = load %struct._Array** %array.addr, align 8
  %call = call i64 @print(%struct._Array* %0)
  %coerce.dive = getelementptr %union.UnionType* %coerce, i32 0, i32 0
  %1 = bitcast double* %coerce.dive to i64*
  store i64 %call, i64* %1, align 1
  %2 = load %struct.__sFILE** @__stdoutp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([2 x i8]* @.str9, i32 0, i32 0))
  %o = bitcast %union.UnionType* %ret to i8**
  store i8* inttoptr (i64 -4222124650659840 to i8*), i8** %o, align 8
  %3 = bitcast %union.UnionType* %retval to i8*
  %4 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 8, i32 8, i1 false)
  %coerce.dive2 = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %5 = bitcast double* %coerce.dive2 to i64*
  %6 = load i64* %5, align 1
  ret i64 %6
}

; Function Attrs: nounwind ssp uwtable
define void @debug_print(i64 %o.coerce) #0 {
entry:
  %o = alloca %union.UnionType, align 8
  %coerce.dive = getelementptr %union.UnionType* %o, i32 0, i32 0
  %0 = bitcast double* %coerce.dive to i64*
  store i64 %o.coerce, i64* %0, align 1
  %1 = load %struct.__sFILE** @__stderrp, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %1, i8* getelementptr inbounds ([26 x i8]* @.str10, i32 0, i32 0))
  %coerce.dive1 = getelementptr %union.UnionType* %o, i32 0, i32 0
  %2 = bitcast double* %coerce.dive1 to i64*
  %3 = load i64* %2, align 1
  call void @print_object(i64 %3)
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call2 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([15 x i8]* @.str11, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 @shift(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %size = alloca i64, align 8
  %o = alloca %union.UnionType, align 8
  %array = alloca %struct._Array*, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %size1 = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size1, align 8
  store i64 %1, i64* %size, align 8
  %2 = load i64* %size, align 8
  %cmp = icmp ugt i64 %2, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %union.UnionType* %retval to i8*
  %4 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 8, i32 8, i1 false)
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64* %size, align 8
  %cmp2 = icmp eq i64 %5, 1
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %6 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %6, i32 0, i32 1
  %7 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %7, i64 0
  %8 = bitcast %union.UnionType* %o to i8*
  %9 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 8, i32 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.then3
  %o4 = bitcast %union.UnionType* %o to i8**
  %10 = load i8** %o4, align 8
  %11 = ptrtoint i8* %10 to i64
  %and = and i64 %11, -4503599627370496
  %cmp5 = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp5 to i32
  %conv6 = sext i32 %conv to i64
  %o7 = bitcast %union.UnionType* %o to i8**
  %12 = load i8** %o7, align 8
  %13 = ptrtoint i8* %12 to i64
  %and8 = and i64 %13, 4222124650659840
  %shr = lshr i64 %and8, 48
  %mul = mul i64 %conv6, %shr
  %cmp9 = icmp ne i64 %mul, 3
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([6 x i8]* @__func__.shift, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 194, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end12:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end12
  %o13 = bitcast %union.UnionType* %o to i8**
  %14 = load i8** %o13, align 8
  %15 = ptrtoint i8* %14 to i64
  %xor = xor i64 %15, -3659174697238528
  %16 = inttoptr i64 %xor to %struct._Array*
  store %struct._Array* %16, %struct._Array** %array, align 8
  %17 = load %struct._Array** %array, align 8
  %list14 = getelementptr inbounds %struct._Array* %17, i32 0, i32 1
  %18 = load %union.UnionType** %list14, align 8
  %arrayidx15 = getelementptr inbounds %union.UnionType* %18, i64 0
  %19 = bitcast %union.UnionType* %ret to i8*
  %20 = bitcast %union.UnionType* %arrayidx15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 8, i32 8, i1 false)
  %21 = load %struct._Array** %array, align 8
  %size16 = getelementptr inbounds %struct._Array* %21, i32 0, i32 2
  %22 = load i64* %size16, align 8
  %dec = add i64 %22, -1
  store i64 %dec, i64* %size16, align 8
  %23 = load %struct._Array** %array, align 8
  %list17 = getelementptr inbounds %struct._Array* %23, i32 0, i32 1
  %24 = load %union.UnionType** %list17, align 8
  %25 = bitcast %union.UnionType* %24 to i8*
  %26 = call i64 @llvm.objectsize.i64(i8* %25, i1 false)
  %cmp18 = icmp ne i64 %26, -1
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %27 = load %struct._Array** %array, align 8
  %list20 = getelementptr inbounds %struct._Array* %27, i32 0, i32 1
  %28 = load %union.UnionType** %list20, align 8
  %29 = bitcast %union.UnionType* %28 to i8*
  %30 = load %struct._Array** %array, align 8
  %list21 = getelementptr inbounds %struct._Array* %30, i32 0, i32 1
  %31 = load %union.UnionType** %list21, align 8
  %add.ptr = getelementptr inbounds %union.UnionType* %31, i64 1
  %32 = bitcast %union.UnionType* %add.ptr to i8*
  %33 = load %struct._Array** %array, align 8
  %size22 = getelementptr inbounds %struct._Array* %33, i32 0, i32 2
  %34 = load i64* %size22, align 8
  %mul23 = mul i64 %34, 8
  %35 = load %struct._Array** %array, align 8
  %list24 = getelementptr inbounds %struct._Array* %35, i32 0, i32 1
  %36 = load %union.UnionType** %list24, align 8
  %37 = bitcast %union.UnionType* %36 to i8*
  %38 = call i64 @llvm.objectsize.i64(i8* %37, i1 false)
  %call = call i8* @__memmove_chk(i8* %29, i8* %32, i64 %mul23, i64 %38) #1
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %39 = load %struct._Array** %array, align 8
  %list25 = getelementptr inbounds %struct._Array* %39, i32 0, i32 1
  %40 = load %union.UnionType** %list25, align 8
  %41 = bitcast %union.UnionType* %40 to i8*
  %42 = load %struct._Array** %array, align 8
  %list26 = getelementptr inbounds %struct._Array* %42, i32 0, i32 1
  %43 = load %union.UnionType** %list26, align 8
  %add.ptr27 = getelementptr inbounds %union.UnionType* %43, i64 1
  %44 = bitcast %union.UnionType* %add.ptr27 to i8*
  %45 = load %struct._Array** %array, align 8
  %size28 = getelementptr inbounds %struct._Array* %45, i32 0, i32 2
  %46 = load i64* %size28, align 8
  %mul29 = mul i64 %46, 8
  %call30 = call i8* @__inline_memmove_chk(i8* %41, i8* %44, i64 %mul29)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %call30, %cond.false ]
  br label %if.end32

if.else:                                          ; preds = %if.end
  %47 = load %struct.__sFILE** @__stderrp, align 8
  %call31 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %47, i8* getelementptr inbounds ([30 x i8]* @.str13, i32 0, i32 0))
  br label %if.end32

if.end32:                                         ; preds = %if.else, %cond.end
  %48 = bitcast %union.UnionType* %retval to i8*
  %49 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %48, i8* %49, i64 8, i32 8, i1 false)
  br label %return

return:                                           ; preds = %if.end32, %if.then
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %50 = bitcast double* %coerce.dive to i64*
  %51 = load i64* %50, align 1
  ret i64 %51
}

; Function Attrs: nounwind readnone
declare i64 @llvm.objectsize.i64(i8*, i1) #5

; Function Attrs: nounwind
declare i8* @__memmove_chk(i8*, i8*, i64, i64) #6

; Function Attrs: inlinehint nounwind ssp uwtable
define internal i8* @__inline_memmove_chk(i8* %__dest, i8* %__src, i64 %__len) #7 {
entry:
  %__dest.addr = alloca i8*, align 8
  %__src.addr = alloca i8*, align 8
  %__len.addr = alloca i64, align 8
  store i8* %__dest, i8** %__dest.addr, align 8
  store i8* %__src, i8** %__src.addr, align 8
  store i64 %__len, i64* %__len.addr, align 8
  %0 = load i8** %__dest.addr, align 8
  %1 = load i8** %__src.addr, align 8
  %2 = load i64* %__len.addr, align 8
  %3 = load i8** %__dest.addr, align 8
  %4 = call i64 @llvm.objectsize.i64(i8* %3, i1 false)
  %call = call i8* @__memmove_chk(i8* %0, i8* %1, i64 %2, i64 %4) #1
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define i64 @push(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %size = alloca i64, align 8
  %ret = alloca %union.UnionType, align 8
  %array = alloca %union.UnionType, align 8
  %value = alloca %union.UnionType, align 8
  %base = alloca %struct._Array*, align 8
  %tmp = alloca i8*, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %size1 = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size1, align 8
  store i64 %1, i64* %size, align 8
  %2 = load i64* %size, align 8
  %cmp = icmp ne i64 %2, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([27 x i8]* @.str14, i32 0, i32 0))
  br label %if.end38

if.else:                                          ; preds = %entry
  %4 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %4, i32 0, i32 1
  %5 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %5, i64 0
  %6 = bitcast %union.UnionType* %array to i8*
  %7 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 8, i32 8, i1 false)
  %8 = load %struct._Array** %args.addr, align 8
  %list2 = getelementptr inbounds %struct._Array* %8, i32 0, i32 1
  %9 = load %union.UnionType** %list2, align 8
  %arrayidx3 = getelementptr inbounds %union.UnionType* %9, i64 1
  %10 = bitcast %union.UnionType* %value to i8*
  %11 = bitcast %union.UnionType* %arrayidx3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.else
  %o = bitcast %union.UnionType* %array to i8**
  %12 = load i8** %o, align 8
  %13 = ptrtoint i8* %12 to i64
  %and = and i64 %13, -4503599627370496
  %cmp4 = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp4 to i32
  %conv5 = sext i32 %conv to i64
  %o6 = bitcast %union.UnionType* %array to i8**
  %14 = load i8** %o6, align 8
  %15 = ptrtoint i8* %14 to i64
  %and7 = and i64 %15, 4222124650659840
  %shr = lshr i64 %and7, 48
  %mul = mul i64 %conv5, %shr
  %cmp8 = icmp ne i64 %mul, 3
  br i1 %cmp8, label %if.then10, label %if.end

if.then10:                                        ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([5 x i8]* @__func__.push, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 214, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %o11 = bitcast %union.UnionType* %array to i8**
  %16 = load i8** %o11, align 8
  %17 = ptrtoint i8* %16 to i64
  %xor = xor i64 %17, -3659174697238528
  %18 = inttoptr i64 %xor to %struct._Array*
  store %struct._Array* %18, %struct._Array** %base, align 8
  %19 = load %struct._Array** %base, align 8
  %size12 = getelementptr inbounds %struct._Array* %19, i32 0, i32 2
  %20 = load i64* %size12, align 8
  %add = add i64 %20, 1
  %mul13 = mul i64 8, %add
  %call14 = call i8* @malloc(i64 %mul13)
  store i8* %call14, i8** %tmp, align 8
  %tobool = icmp ne i8* %call14, null
  br i1 %tobool, label %if.else17, label %if.then15

if.then15:                                        ; preds = %do.end
  %21 = load %struct.__sFILE** @__stderrp, align 8
  %call16 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %21, i8* getelementptr inbounds ([34 x i8]* @.str15, i32 0, i32 0))
  br label %if.end37

if.else17:                                        ; preds = %do.end
  %22 = load i8** %tmp, align 8
  %23 = call i64 @llvm.objectsize.i64(i8* %22, i1 false)
  %cmp18 = icmp ne i64 %23, -1
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else17
  %24 = load i8** %tmp, align 8
  %25 = load %struct._Array** %base, align 8
  %list20 = getelementptr inbounds %struct._Array* %25, i32 0, i32 1
  %26 = load %union.UnionType** %list20, align 8
  %27 = bitcast %union.UnionType* %26 to i8*
  %28 = load %struct._Array** %base, align 8
  %size21 = getelementptr inbounds %struct._Array* %28, i32 0, i32 2
  %29 = load i64* %size21, align 8
  %mul22 = mul i64 8, %29
  %30 = load i8** %tmp, align 8
  %31 = call i64 @llvm.objectsize.i64(i8* %30, i1 false)
  %call23 = call i8* @__memcpy_chk(i8* %24, i8* %27, i64 %mul22, i64 %31) #1
  br label %cond.end

cond.false:                                       ; preds = %if.else17
  %32 = load i8** %tmp, align 8
  %33 = load %struct._Array** %base, align 8
  %list24 = getelementptr inbounds %struct._Array* %33, i32 0, i32 1
  %34 = load %union.UnionType** %list24, align 8
  %35 = bitcast %union.UnionType* %34 to i8*
  %36 = load %struct._Array** %base, align 8
  %size25 = getelementptr inbounds %struct._Array* %36, i32 0, i32 2
  %37 = load i64* %size25, align 8
  %mul26 = mul i64 8, %37
  %call27 = call i8* @__inline_memcpy_chk(i8* %32, i8* %35, i64 %mul26)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call23, %cond.true ], [ %call27, %cond.false ]
  %38 = load i8** %tmp, align 8
  %39 = bitcast i8* %38 to %union.UnionType*
  %40 = load %struct._Array** %base, align 8
  %list28 = getelementptr inbounds %struct._Array* %40, i32 0, i32 1
  store %union.UnionType* %39, %union.UnionType** %list28, align 8
  %41 = load %struct._Array** %base, align 8
  %size29 = getelementptr inbounds %struct._Array* %41, i32 0, i32 2
  %42 = load i64* %size29, align 8
  %43 = load %struct._Array** %base, align 8
  %list30 = getelementptr inbounds %struct._Array* %43, i32 0, i32 1
  %44 = load %union.UnionType** %list30, align 8
  %arrayidx31 = getelementptr inbounds %union.UnionType* %44, i64 %42
  %45 = bitcast %union.UnionType* %arrayidx31 to i8*
  %46 = bitcast %union.UnionType* %value to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 8, i32 8, i1 false)
  %47 = load %struct._Array** %base, align 8
  %size32 = getelementptr inbounds %struct._Array* %47, i32 0, i32 2
  %48 = load i64* %size32, align 8
  %inc = add i64 %48, 1
  store i64 %inc, i64* %size32, align 8
  %49 = load %struct._Array** %base, align 8
  %size33 = getelementptr inbounds %struct._Array* %49, i32 0, i32 2
  %50 = load i64* %size33, align 8
  %and34 = and i64 %50, 4294967295
  %or = or i64 %and34, -4503599627370496
  %or35 = or i64 %or, 281474976710656
  %51 = inttoptr i64 %or35 to i8*
  %o36 = bitcast %union.UnionType* %ret to i8**
  store i8* %51, i8** %o36, align 8
  br label %if.end37

if.end37:                                         ; preds = %cond.end, %if.then15
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then
  %52 = bitcast %union.UnionType* %retval to i8*
  %53 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* %53, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %54 = bitcast double* %coerce.dive to i64*
  %55 = load i64* %54, align 1
  ret i64 %55
}

declare i8* @malloc(i64) #4

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #6

; Function Attrs: inlinehint nounwind ssp uwtable
define internal i8* @__inline_memcpy_chk(i8* %__dest, i8* %__src, i64 %__len) #7 {
entry:
  %__dest.addr = alloca i8*, align 8
  %__src.addr = alloca i8*, align 8
  %__len.addr = alloca i64, align 8
  store i8* %__dest, i8** %__dest.addr, align 8
  store i8* %__src, i8** %__src.addr, align 8
  store i64 %__len, i64* %__len.addr, align 8
  %0 = load i8** %__dest.addr, align 8
  %1 = load i8** %__src.addr, align 8
  %2 = load i64* %__len.addr, align 8
  %3 = load i8** %__dest.addr, align 8
  %4 = call i64 @llvm.objectsize.i64(i8* %3, i1 false)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 %2, i64 %4) #1
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define void @new_Undef() #0 {
entry:
  %o = alloca %struct._Undef*, align 8
  %call = call i8* @calloc(i64 4, i64 1)
  %0 = bitcast i8* %call to %struct._Undef*
  store %struct._Undef* %0, %struct._Undef** %o, align 8
  %1 = load %struct._Undef** %o, align 8
  %2 = ptrtoint %struct._Undef* %1 to i64
  %or = or i64 %2, -4503599627370496
  %or1 = or i64 %or, 2814749767106560
  %3 = inttoptr i64 %or1 to i8*
  store i8* %3, i8** bitcast (%union.UnionType* @undef to i8**), align 8
  ret void
}

declare i8* @calloc(i64, i64) #4

; Function Attrs: nounwind ssp uwtable
define i64 @get_undef_value() #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %0 = bitcast %union.UnionType* %retval to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%union.UnionType* @undef to i8*), i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %1 = bitcast double* %coerce.dive to i64*
  %2 = load i64* %1, align 1
  ret i64 %2
}

; Function Attrs: nounwind ssp uwtable
define void @init_table() #0 {
entry:
  %table = alloca %union.UnionType*, align 8
  %i = alloca i64, align 8
  %call = call i8* @calloc(i64 8, i64 512)
  %0 = bitcast i8* %call to %union.UnionType*
  store %union.UnionType* %0, %union.UnionType** %table, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64* %i, align 8
  %cmp = icmp ult i64 %1, 512
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64* %i, align 8
  %3 = load %union.UnionType** %table, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %3, i64 %2
  %4 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* bitcast (%union.UnionType* @undef to i8*), i64 8, i32 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i64* %i, align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = load %union.UnionType** %table, align 8
  store %union.UnionType* %6, %union.UnionType** @base_hash_table, align 8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @init_package_map() #0 {
entry:
  %hash = alloca %struct._Hash*, align 8
  %call = call i8* @calloc(i64 32, i64 1)
  %0 = bitcast i8* %call to %struct._Hash*
  store %struct._Hash* %0, %struct._Hash** %hash, align 8
  %call1 = call i8* @calloc(i64 8, i64 512)
  %1 = bitcast i8* %call1 to %union.UnionType*
  %2 = load %struct._Hash** %hash, align 8
  %table = getelementptr inbounds %struct._Hash* %2, i32 0, i32 1
  store %union.UnionType* %1, %union.UnionType** %table, align 8
  %3 = load %struct._Hash** %hash, align 8
  %table2 = getelementptr inbounds %struct._Hash* %3, i32 0, i32 1
  %4 = load %union.UnionType** %table2, align 8
  %5 = bitcast %union.UnionType* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64(i8* %5, i1 false)
  %cmp = icmp ne i64 %6, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load %struct._Hash** %hash, align 8
  %table3 = getelementptr inbounds %struct._Hash* %7, i32 0, i32 1
  %8 = load %union.UnionType** %table3, align 8
  %9 = bitcast %union.UnionType* %8 to i8*
  %10 = load %union.UnionType** @base_hash_table, align 8
  %11 = bitcast %union.UnionType* %10 to i8*
  %12 = load %struct._Hash** %hash, align 8
  %table4 = getelementptr inbounds %struct._Hash* %12, i32 0, i32 1
  %13 = load %union.UnionType** %table4, align 8
  %14 = bitcast %union.UnionType* %13 to i8*
  %15 = call i64 @llvm.objectsize.i64(i8* %14, i1 false)
  %call5 = call i8* @__memcpy_chk(i8* %9, i8* %11, i64 4096, i64 %15) #1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %16 = load %struct._Hash** %hash, align 8
  %table6 = getelementptr inbounds %struct._Hash* %16, i32 0, i32 1
  %17 = load %union.UnionType** %table6, align 8
  %18 = bitcast %union.UnionType* %17 to i8*
  %19 = load %union.UnionType** @base_hash_table, align 8
  %20 = bitcast %union.UnionType* %19 to i8*
  %call7 = call i8* @__inline_memcpy_chk(i8* %18, i8* %20, i64 4096)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call5, %cond.true ], [ %call7, %cond.false ]
  %call8 = call i8* @calloc(i64 8, i64 512)
  %21 = bitcast i8* %call8 to %struct._String**
  %22 = load %struct._Hash** %hash, align 8
  %keys = getelementptr inbounds %struct._Hash* %22, i32 0, i32 2
  store %struct._String** %21, %struct._String*** %keys, align 8
  %23 = load %struct._Hash** %hash, align 8
  store %struct._Hash* %23, %struct._Hash** @pkg_map, align 8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @global_init() #0 {
entry:
  call void @new_Undef()
  call void @init_table()
  call void @init_package_map()
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 @make_hash(i8* %_str, i64 %len) #0 {
entry:
  %_str.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %str = alloca i8*, align 8
  %hash = alloca i64, align 8
  store i8* %_str, i8** %_str.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8** %_str.addr, align 8
  store i8* %0, i8** %str, align 8
  store i64 5381, i64* %hash, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i64* %len.addr, align 8
  %dec = add i64 %1, -1
  store i64 %dec, i64* %len.addr, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i64* %hash, align 8
  %shl = shl i64 %2, 5
  %3 = load i64* %hash, align 8
  %add = add i64 %shl, %3
  %4 = load i8** %str, align 8
  %incdec.ptr = getelementptr inbounds i8* %4, i32 1
  store i8* %incdec.ptr, i8** %str, align 8
  %5 = load i8* %4, align 1
  %conv = sext i8 %5 to i64
  %add1 = add i64 %add, %conv
  store i64 %add1, i64* %hash, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %6 = load i64* %hash, align 8
  ret i64 %6
}

; Function Attrs: nounwind ssp uwtable
define i64 @new_String(i8* %str) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %str.addr = alloca i8*, align 8
  %ret = alloca %union.UnionType, align 8
  %o = alloca %struct._String*, align 8
  store i8* %str, i8** %str.addr, align 8
  %call = call i8* @calloc(i64 32, i64 1)
  %0 = bitcast i8* %call to %struct._String*
  store %struct._String* %0, %struct._String** %o, align 8
  %1 = load %struct._String** %o, align 8
  %header = getelementptr inbounds %struct._String* %1, i32 0, i32 0
  store i32 2, i32* %header, align 4
  %2 = load i8** %str.addr, align 8
  %call1 = call i64 @strlen(i8* %2)
  %add = add i64 %call1, 1
  %3 = load %struct._String** %o, align 8
  %len = getelementptr inbounds %struct._String* %3, i32 0, i32 2
  store i64 %add, i64* %len, align 8
  %4 = load %struct._String** %o, align 8
  %len2 = getelementptr inbounds %struct._String* %4, i32 0, i32 2
  %5 = load i64* %len2, align 8
  %call3 = call i8* @malloc(i64 %5)
  %6 = load %struct._String** %o, align 8
  %s = getelementptr inbounds %struct._String* %6, i32 0, i32 1
  store i8* %call3, i8** %s, align 8
  %7 = load %struct._String** %o, align 8
  %s4 = getelementptr inbounds %struct._String* %7, i32 0, i32 1
  %8 = load i8** %s4, align 8
  %9 = call i64 @llvm.objectsize.i64(i8* %8, i1 false)
  %cmp = icmp ne i64 %9, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load %struct._String** %o, align 8
  %s5 = getelementptr inbounds %struct._String* %10, i32 0, i32 1
  %11 = load i8** %s5, align 8
  %12 = load i8** %str.addr, align 8
  %13 = load %struct._String** %o, align 8
  %len6 = getelementptr inbounds %struct._String* %13, i32 0, i32 2
  %14 = load i64* %len6, align 8
  %15 = load %struct._String** %o, align 8
  %s7 = getelementptr inbounds %struct._String* %15, i32 0, i32 1
  %16 = load i8** %s7, align 8
  %17 = call i64 @llvm.objectsize.i64(i8* %16, i1 false)
  %call8 = call i8* @__memcpy_chk(i8* %11, i8* %12, i64 %14, i64 %17) #1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load %struct._String** %o, align 8
  %s9 = getelementptr inbounds %struct._String* %18, i32 0, i32 1
  %19 = load i8** %s9, align 8
  %20 = load i8** %str.addr, align 8
  %21 = load %struct._String** %o, align 8
  %len10 = getelementptr inbounds %struct._String* %21, i32 0, i32 2
  %22 = load i64* %len10, align 8
  %call11 = call i8* @__inline_memcpy_chk(i8* %19, i8* %20, i64 %22)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call8, %cond.true ], [ %call11, %cond.false ]
  %23 = load i8** %str.addr, align 8
  %24 = load %struct._String** %o, align 8
  %len12 = getelementptr inbounds %struct._String* %24, i32 0, i32 2
  %25 = load i64* %len12, align 8
  %call13 = call i64 @make_hash(i8* %23, i64 %25)
  %rem = urem i64 %call13, 512
  %26 = load %struct._String** %o, align 8
  %hash = getelementptr inbounds %struct._String* %26, i32 0, i32 3
  store i64 %rem, i64* %hash, align 8
  %27 = load %struct._String** %o, align 8
  %28 = ptrtoint %struct._String* %27 to i64
  %or = or i64 %28, -4503599627370496
  %or14 = or i64 %or, 562949953421312
  %29 = inttoptr i64 %or14 to i8*
  %o15 = bitcast %union.UnionType* %ret to i8**
  store i8* %29, i8** %o15, align 8
  %30 = bitcast %union.UnionType* %retval to i8*
  %31 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %32 = bitcast double* %coerce.dive to i64*
  %33 = load i64* %32, align 1
  ret i64 %33
}

declare i64 @strlen(i8*) #4

; Function Attrs: nounwind ssp uwtable
define void @_unshift(%struct._Array* %base, i8* %pkg_name) #0 {
entry:
  %base.addr = alloca %struct._Array*, align 8
  %pkg_name.addr = alloca i8*, align 8
  %tmp = alloca %union.UnionType*, align 8
  %coerce = alloca %union.UnionType, align 8
  store %struct._Array* %base, %struct._Array** %base.addr, align 8
  store i8* %pkg_name, i8** %pkg_name.addr, align 8
  %0 = load %struct._Array** %base.addr, align 8
  %size = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size, align 8
  %add = add i64 %1, 1
  %mul = mul i64 8, %add
  %call = call i8* @malloc(i64 %mul)
  %2 = bitcast i8* %call to %union.UnionType*
  store %union.UnionType* %2, %union.UnionType** %tmp, align 8
  %tobool = icmp ne %union.UnionType* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([34 x i8]* @.str15, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %union.UnionType** %tmp, align 8
  %add.ptr = getelementptr inbounds %union.UnionType* %4, i64 1
  %5 = bitcast %union.UnionType* %add.ptr to i8*
  %6 = call i64 @llvm.objectsize.i64(i8* %5, i1 false)
  %cmp = icmp ne i64 %6, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %7 = load %union.UnionType** %tmp, align 8
  %add.ptr2 = getelementptr inbounds %union.UnionType* %7, i64 1
  %8 = bitcast %union.UnionType* %add.ptr2 to i8*
  %9 = load %struct._Array** %base.addr, align 8
  %list = getelementptr inbounds %struct._Array* %9, i32 0, i32 1
  %10 = load %union.UnionType** %list, align 8
  %11 = bitcast %union.UnionType* %10 to i8*
  %12 = load %struct._Array** %base.addr, align 8
  %size3 = getelementptr inbounds %struct._Array* %12, i32 0, i32 2
  %13 = load i64* %size3, align 8
  %mul4 = mul i64 %13, 8
  %14 = load %union.UnionType** %tmp, align 8
  %add.ptr5 = getelementptr inbounds %union.UnionType* %14, i64 1
  %15 = bitcast %union.UnionType* %add.ptr5 to i8*
  %16 = call i64 @llvm.objectsize.i64(i8* %15, i1 false)
  %call6 = call i8* @__memcpy_chk(i8* %8, i8* %11, i64 %mul4, i64 %16) #1
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %17 = load %union.UnionType** %tmp, align 8
  %add.ptr7 = getelementptr inbounds %union.UnionType* %17, i64 1
  %18 = bitcast %union.UnionType* %add.ptr7 to i8*
  %19 = load %struct._Array** %base.addr, align 8
  %list8 = getelementptr inbounds %struct._Array* %19, i32 0, i32 1
  %20 = load %union.UnionType** %list8, align 8
  %21 = bitcast %union.UnionType* %20 to i8*
  %22 = load %struct._Array** %base.addr, align 8
  %size9 = getelementptr inbounds %struct._Array* %22, i32 0, i32 2
  %23 = load i64* %size9, align 8
  %mul10 = mul i64 %23, 8
  %call11 = call i8* @__inline_memcpy_chk(i8* %18, i8* %21, i64 %mul10)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call6, %cond.true ], [ %call11, %cond.false ]
  %24 = load %union.UnionType** %tmp, align 8
  %25 = load %struct._Array** %base.addr, align 8
  %list12 = getelementptr inbounds %struct._Array* %25, i32 0, i32 1
  store %union.UnionType* %24, %union.UnionType** %list12, align 8
  %26 = load %struct._Array** %base.addr, align 8
  %list13 = getelementptr inbounds %struct._Array* %26, i32 0, i32 1
  %27 = load %union.UnionType** %list13, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %27, i64 0
  %28 = load i8** %pkg_name.addr, align 8
  %call14 = call i64 @new_String(i8* %28)
  %coerce.dive = getelementptr %union.UnionType* %coerce, i32 0, i32 0
  %29 = bitcast double* %coerce.dive to i64*
  store i64 %call14, i64* %29, align 1
  %30 = bitcast %union.UnionType* %arrayidx to i8*
  %31 = bitcast %union.UnionType* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false)
  %32 = load %struct._Array** %base.addr, align 8
  %size15 = getelementptr inbounds %struct._Array* %32, i32 0, i32 2
  %33 = load i64* %size15, align 8
  %inc = add i64 %33, 1
  store i64 %inc, i64* %size15, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @_make_method_argument(%struct._Array* %base, %struct._BlessedObject* %self) #0 {
entry:
  %base.addr = alloca %struct._Array*, align 8
  %self.addr = alloca %struct._BlessedObject*, align 8
  %tmp = alloca %union.UnionType*, align 8
  %elem = alloca %union.UnionType, align 8
  store %struct._Array* %base, %struct._Array** %base.addr, align 8
  store %struct._BlessedObject* %self, %struct._BlessedObject** %self.addr, align 8
  %0 = load %struct._Array** %base.addr, align 8
  %size = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size, align 8
  %add = add i64 %1, 1
  %mul = mul i64 8, %add
  %call = call i8* @malloc(i64 %mul)
  %2 = bitcast i8* %call to %union.UnionType*
  store %union.UnionType* %2, %union.UnionType** %tmp, align 8
  %tobool = icmp ne %union.UnionType* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([34 x i8]* @.str15, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %union.UnionType** %tmp, align 8
  %add.ptr = getelementptr inbounds %union.UnionType* %4, i64 1
  %5 = bitcast %union.UnionType* %add.ptr to i8*
  %6 = call i64 @llvm.objectsize.i64(i8* %5, i1 false)
  %cmp = icmp ne i64 %6, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %7 = load %union.UnionType** %tmp, align 8
  %add.ptr2 = getelementptr inbounds %union.UnionType* %7, i64 1
  %8 = bitcast %union.UnionType* %add.ptr2 to i8*
  %9 = load %struct._Array** %base.addr, align 8
  %list = getelementptr inbounds %struct._Array* %9, i32 0, i32 1
  %10 = load %union.UnionType** %list, align 8
  %11 = bitcast %union.UnionType* %10 to i8*
  %12 = load %struct._Array** %base.addr, align 8
  %size3 = getelementptr inbounds %struct._Array* %12, i32 0, i32 2
  %13 = load i64* %size3, align 8
  %mul4 = mul i64 %13, 8
  %14 = load %union.UnionType** %tmp, align 8
  %add.ptr5 = getelementptr inbounds %union.UnionType* %14, i64 1
  %15 = bitcast %union.UnionType* %add.ptr5 to i8*
  %16 = call i64 @llvm.objectsize.i64(i8* %15, i1 false)
  %call6 = call i8* @__memcpy_chk(i8* %8, i8* %11, i64 %mul4, i64 %16) #1
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %17 = load %union.UnionType** %tmp, align 8
  %add.ptr7 = getelementptr inbounds %union.UnionType* %17, i64 1
  %18 = bitcast %union.UnionType* %add.ptr7 to i8*
  %19 = load %struct._Array** %base.addr, align 8
  %list8 = getelementptr inbounds %struct._Array* %19, i32 0, i32 1
  %20 = load %union.UnionType** %list8, align 8
  %21 = bitcast %union.UnionType* %20 to i8*
  %22 = load %struct._Array** %base.addr, align 8
  %size9 = getelementptr inbounds %struct._Array* %22, i32 0, i32 2
  %23 = load i64* %size9, align 8
  %mul10 = mul i64 %23, 8
  %call11 = call i8* @__inline_memcpy_chk(i8* %18, i8* %21, i64 %mul10)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call6, %cond.true ], [ %call11, %cond.false ]
  %24 = load %union.UnionType** %tmp, align 8
  %25 = load %struct._Array** %base.addr, align 8
  %list12 = getelementptr inbounds %struct._Array* %25, i32 0, i32 1
  store %union.UnionType* %24, %union.UnionType** %list12, align 8
  %26 = load %struct._BlessedObject** %self.addr, align 8
  %27 = ptrtoint %struct._BlessedObject* %26 to i64
  %or = or i64 %27, -4503599627370496
  %or14 = or i64 %or, 2251799813685248
  %28 = inttoptr i64 %or14 to i8*
  %o = bitcast %union.UnionType* %elem to i8**
  store i8* %28, i8** %o, align 8
  %29 = load %struct._Array** %base.addr, align 8
  %list15 = getelementptr inbounds %struct._Array* %29, i32 0, i32 1
  %30 = load %union.UnionType** %list15, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %30, i64 0
  %31 = bitcast %union.UnionType* %arrayidx to i8*
  %32 = bitcast %union.UnionType* %elem to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %31, i8* %32, i64 8, i32 8, i1 false)
  %33 = load %struct._Array** %base.addr, align 8
  %size16 = getelementptr inbounds %struct._Array* %33, i32 0, i32 2
  %34 = load i64* %size16, align 8
  %inc = add i64 %34, 1
  store i64 %inc, i64* %size16, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @Hash_add(%struct._Hash* %hash, %struct._String* %key, i64 %elem.coerce) #0 {
entry:
  %hash.addr = alloca %struct._Hash*, align 8
  %key.addr = alloca %struct._String*, align 8
  %elem = alloca %union.UnionType, align 8
  %size = alloca i64, align 8
  store %struct._Hash* %hash, %struct._Hash** %hash.addr, align 8
  store %struct._String* %key, %struct._String** %key.addr, align 8
  %coerce.dive = getelementptr %union.UnionType* %elem, i32 0, i32 0
  %0 = bitcast double* %coerce.dive to i64*
  store i64 %elem.coerce, i64* %0, align 1
  %1 = load %struct._Hash** %hash.addr, align 8
  %size1 = getelementptr inbounds %struct._Hash* %1, i32 0, i32 3
  %2 = load i64* %size1, align 8
  store i64 %2, i64* %size, align 8
  %3 = load %struct._String** %key.addr, align 8
  %hash2 = getelementptr inbounds %struct._String* %3, i32 0, i32 3
  %4 = load i64* %hash2, align 8
  %5 = load %struct._Hash** %hash.addr, align 8
  %table = getelementptr inbounds %struct._Hash* %5, i32 0, i32 1
  %6 = load %union.UnionType** %table, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %6, i64 %4
  %7 = bitcast %union.UnionType* %arrayidx to i8*
  %8 = bitcast %union.UnionType* %elem to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = load %struct._String** %key.addr, align 8
  %10 = load i64* %size, align 8
  %add = add i64 %10, 1
  %11 = load %struct._Hash** %hash.addr, align 8
  %keys = getelementptr inbounds %struct._Hash* %11, i32 0, i32 2
  %12 = load %struct._String*** %keys, align 8
  %arrayidx3 = getelementptr inbounds %struct._String** %12, i64 %add
  store %struct._String* %9, %struct._String** %arrayidx3, align 8
  %13 = load %struct._Hash** %hash.addr, align 8
  %size4 = getelementptr inbounds %struct._Hash* %13, i32 0, i32 3
  %14 = load i64* %size4, align 8
  %inc = add i64 %14, 1
  store i64 %inc, i64* %size4, align 8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 @Hash_get(%struct._Hash* %hash, %struct._String* %key) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %hash.addr = alloca %struct._Hash*, align 8
  %key.addr = alloca %struct._String*, align 8
  store %struct._Hash* %hash, %struct._Hash** %hash.addr, align 8
  store %struct._String* %key, %struct._String** %key.addr, align 8
  %0 = load %struct._String** %key.addr, align 8
  %hash1 = getelementptr inbounds %struct._String* %0, i32 0, i32 3
  %1 = load i64* %hash1, align 8
  %2 = load %struct._Hash** %hash.addr, align 8
  %table = getelementptr inbounds %struct._Hash* %2, i32 0, i32 1
  %3 = load %union.UnionType** %table, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %3, i64 %1
  %4 = bitcast %union.UnionType* %retval to i8*
  %5 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %6 = bitcast double* %coerce.dive to i64*
  %7 = load i64* %6, align 1
  ret i64 %7
}

; Function Attrs: nounwind ssp uwtable
define i64 @bless(%struct._Array* %args) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %self = alloca %union.UnionType, align 8
  %class = alloca %union.UnionType, align 8
  %blessed = alloca %struct._BlessedObject*, align 8
  %pkg_name = alloca i8*, align 8
  %hash_ref = alloca %struct._HashRef*, align 8
  %hash = alloca %struct._Hash*, align 8
  %s47 = alloca %union.UnionType, align 8
  %mtds = alloca %union.UnionType, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %size = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size, align 8
  %cmp = icmp ne i64 %1, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([54 x i8]* @.str16, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %3, i32 0, i32 1
  %4 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %4, i64 0
  %5 = bitcast %union.UnionType* %self to i8*
  %6 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 8, i32 8, i1 false)
  %7 = load %struct._Array** %args.addr, align 8
  %list1 = getelementptr inbounds %struct._Array* %7, i32 0, i32 1
  %8 = load %union.UnionType** %list1, align 8
  %arrayidx2 = getelementptr inbounds %union.UnionType* %8, i64 1
  %9 = bitcast %union.UnionType* %class to i8*
  %10 = bitcast %union.UnionType* %arrayidx2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false)
  %call3 = call i8* @calloc(i64 32, i64 1)
  %11 = bitcast i8* %call3 to %struct._BlessedObject*
  store %struct._BlessedObject* %11, %struct._BlessedObject** %blessed, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %o = bitcast %union.UnionType* %self to i8**
  %12 = load i8** %o, align 8
  %13 = ptrtoint i8* %12 to i64
  %and = and i64 %13, -4503599627370496
  %cmp4 = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp4 to i32
  %conv5 = sext i32 %conv to i64
  %o6 = bitcast %union.UnionType* %self to i8**
  %14 = load i8** %o6, align 8
  %15 = ptrtoint i8* %14 to i64
  %and7 = and i64 %15, 4222124650659840
  %shr = lshr i64 %and7, 48
  %mul = mul i64 %conv5, %shr
  %cmp8 = icmp ne i64 %mul, 6
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([6 x i8]* @__func__.bless, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 369, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end11:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end11
  %o12 = bitcast %union.UnionType* %class to i8**
  %16 = load i8** %o12, align 8
  %17 = ptrtoint i8* %16 to i64
  %and13 = and i64 %17, -4503599627370496
  %cmp14 = icmp eq i64 %and13, -4503599627370496
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = sext i32 %conv15 to i64
  %o17 = bitcast %union.UnionType* %class to i8**
  %18 = load i8** %o17, align 8
  %19 = ptrtoint i8* %18 to i64
  %and18 = and i64 %19, 4222124650659840
  %shr19 = lshr i64 %and18, 48
  %mul20 = mul i64 %conv16, %shr19
  %cmp21 = icmp eq i64 %mul20, 7
  br i1 %cmp21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %o23 = bitcast %union.UnionType* %class to i8**
  %20 = load i8** %o23, align 8
  %21 = ptrtoint i8* %20 to i64
  %xor = xor i64 %21, -2533274790395904
  %22 = inttoptr i64 %xor to %struct._Object*
  %v = getelementptr inbounds %struct._Object* %22, i32 0, i32 1
  %23 = bitcast %union.UnionType* %class to i8*
  %24 = bitcast %union.UnionType* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 8, i32 8, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %25 = bitcast %union.UnionType* %class to i8*
  %26 = bitcast %union.UnionType* %class to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 8, i32 8, i1 false)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  br label %do.body24

do.body24:                                        ; preds = %cond.end
  %o25 = bitcast %union.UnionType* %class to i8**
  %27 = load i8** %o25, align 8
  %28 = ptrtoint i8* %27 to i64
  %and26 = and i64 %28, -4503599627370496
  %cmp27 = icmp eq i64 %and26, -4503599627370496
  %conv28 = zext i1 %cmp27 to i32
  %conv29 = sext i32 %conv28 to i64
  %o30 = bitcast %union.UnionType* %class to i8**
  %29 = load i8** %o30, align 8
  %30 = ptrtoint i8* %29 to i64
  %and31 = and i64 %30, 4222124650659840
  %shr32 = lshr i64 %and31, 48
  %mul33 = mul i64 %conv29, %shr32
  %cmp34 = icmp ne i64 %mul33, 2
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %do.body24
  call void @__assert_rtn(i8* getelementptr inbounds ([6 x i8]* @__func__.bless, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 371, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end37:                                         ; preds = %do.body24
  br label %do.end38

do.end38:                                         ; preds = %if.end37
  %o39 = bitcast %union.UnionType* %class to i8**
  %31 = load i8** %o39, align 8
  %32 = ptrtoint i8* %31 to i64
  %xor40 = xor i64 %32, -3940649673949184
  %33 = inttoptr i64 %xor40 to %struct._String*
  %s = getelementptr inbounds %struct._String* %33, i32 0, i32 1
  %34 = load i8** %s, align 8
  store i8* %34, i8** %pkg_name, align 8
  %o41 = bitcast %union.UnionType* %self to i8**
  %35 = load i8** %o41, align 8
  %36 = ptrtoint i8* %35 to i64
  %xor42 = xor i64 %36, -2814749767106560
  %37 = inttoptr i64 %xor42 to %struct._HashRef*
  store %struct._HashRef* %37, %struct._HashRef** %hash_ref, align 8
  %38 = load %struct._HashRef** %hash_ref, align 8
  %v43 = getelementptr inbounds %struct._HashRef* %38, i32 0, i32 1
  %o44 = bitcast %union.UnionType* %v43 to i8**
  %39 = load i8** %o44, align 8
  %40 = ptrtoint i8* %39 to i64
  %xor45 = xor i64 %40, -3096224743817216
  %41 = inttoptr i64 %xor45 to %struct._Hash*
  store %struct._Hash* %41, %struct._Hash** %hash, align 8
  %42 = load %struct._BlessedObject** %blessed, align 8
  %members = getelementptr inbounds %struct._BlessedObject* %42, i32 0, i32 1
  %43 = bitcast %union.UnionType* %members to i8*
  %44 = bitcast %union.UnionType* %self to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %43, i8* %44, i64 8, i32 8, i1 false)
  %45 = load i8** %pkg_name, align 8
  %46 = load %struct._BlessedObject** %blessed, align 8
  %pkg_name46 = getelementptr inbounds %struct._BlessedObject* %46, i32 0, i32 3
  store i8* %45, i8** %pkg_name46, align 8
  %47 = load i8** %pkg_name, align 8
  %call48 = call i64 @new_String(i8* %47)
  %coerce.dive = getelementptr %union.UnionType* %s47, i32 0, i32 0
  %48 = bitcast double* %coerce.dive to i64*
  store i64 %call48, i64* %48, align 1
  %49 = load %struct._Hash** @pkg_map, align 8
  %o49 = bitcast %union.UnionType* %s47 to i8**
  %50 = load i8** %o49, align 8
  %51 = ptrtoint i8* %50 to i64
  %xor50 = xor i64 %51, -3940649673949184
  %52 = inttoptr i64 %xor50 to %struct._String*
  %call51 = call i64 @Hash_get(%struct._Hash* %49, %struct._String* %52)
  %coerce.dive52 = getelementptr %union.UnionType* %mtds, i32 0, i32 0
  %53 = bitcast double* %coerce.dive52 to i64*
  store i64 %call51, i64* %53, align 1
  br label %do.body53

do.body53:                                        ; preds = %do.end38
  %o54 = bitcast %union.UnionType* %mtds to i8**
  %54 = load i8** %o54, align 8
  %55 = ptrtoint i8* %54 to i64
  %and55 = and i64 %55, -4503599627370496
  %cmp56 = icmp eq i64 %and55, -4503599627370496
  %conv57 = zext i1 %cmp56 to i32
  %conv58 = sext i32 %conv57 to i64
  %o59 = bitcast %union.UnionType* %mtds to i8**
  %56 = load i8** %o59, align 8
  %57 = ptrtoint i8* %56 to i64
  %and60 = and i64 %57, 4222124650659840
  %shr61 = lshr i64 %and60, 48
  %mul62 = mul i64 %conv58, %shr61
  %cmp63 = icmp ne i64 %mul62, 5
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %do.body53
  call void @__assert_rtn(i8* getelementptr inbounds ([6 x i8]* @__func__.bless, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 381, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end66:                                         ; preds = %do.body53
  br label %do.end67

do.end67:                                         ; preds = %if.end66
  %o68 = bitcast %union.UnionType* %mtds to i8**
  %58 = load i8** %o68, align 8
  %59 = ptrtoint i8* %58 to i64
  %xor69 = xor i64 %59, -3096224743817216
  %60 = inttoptr i64 %xor69 to %struct._Hash*
  %61 = load %struct._BlessedObject** %blessed, align 8
  %mtds70 = getelementptr inbounds %struct._BlessedObject* %61, i32 0, i32 2
  store %struct._Hash* %60, %struct._Hash** %mtds70, align 8
  %62 = load %struct._BlessedObject** %blessed, align 8
  %63 = ptrtoint %struct._BlessedObject* %62 to i64
  %or = or i64 %63, -4503599627370496
  %or71 = or i64 %or, 2251799813685248
  %64 = inttoptr i64 %or71 to i8*
  %o72 = bitcast %union.UnionType* %ret to i8**
  store i8* %64, i8** %o72, align 8
  %65 = bitcast %union.UnionType* %retval to i8*
  %66 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* %66, i64 8, i32 8, i1 false)
  %coerce.dive73 = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %67 = bitcast double* %coerce.dive73 to i64*
  %68 = load i64* %67, align 1
  ret i64 %68
}

; Function Attrs: nounwind ssp uwtable
define %struct._Object* @fetch_object() #0 {
entry:
  %call = call i8* @calloc(i64 64, i64 1)
  %0 = bitcast i8* %call to %struct._Object*
  ret %struct._Object* %0
}

; Function Attrs: nounwind ssp uwtable
define %struct._Hash* @get_pkg(i8* %pkg_name) #0 {
entry:
  %retval = alloca %struct._Hash*, align 8
  %pkg_name.addr = alloca i8*, align 8
  %ret = alloca %struct._Hash*, align 8
  %_key = alloca %union.UnionType, align 8
  %key = alloca %struct._String*, align 8
  %pkg = alloca %union.UnionType, align 8
  %hash = alloca %struct._Hash*, align 8
  %value = alloca %union.UnionType, align 8
  store i8* %pkg_name, i8** %pkg_name.addr, align 8
  store %struct._Hash* null, %struct._Hash** %ret, align 8
  %0 = load i8** %pkg_name.addr, align 8
  %call = call i64 @new_String(i8* %0)
  %coerce.dive = getelementptr %union.UnionType* %_key, i32 0, i32 0
  %1 = bitcast double* %coerce.dive to i64*
  store i64 %call, i64* %1, align 1
  %o = bitcast %union.UnionType* %_key to i8**
  %2 = load i8** %o, align 8
  %3 = ptrtoint i8* %2 to i64
  %xor = xor i64 %3, -3940649673949184
  %4 = inttoptr i64 %xor to %struct._String*
  store %struct._String* %4, %struct._String** %key, align 8
  %5 = load %struct._Hash** @pkg_map, align 8
  %6 = load %struct._String** %key, align 8
  %call1 = call i64 @Hash_get(%struct._Hash* %5, %struct._String* %6)
  %coerce.dive2 = getelementptr %union.UnionType* %pkg, i32 0, i32 0
  %7 = bitcast double* %coerce.dive2 to i64*
  store i64 %call1, i64* %7, align 1
  %o3 = bitcast %union.UnionType* %pkg to i8**
  %8 = load i8** %o3, align 8
  %9 = ptrtoint i8* %8 to i64
  %and = and i64 %9, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv4 = sext i32 %conv to i64
  %o5 = bitcast %union.UnionType* %pkg to i8**
  %10 = load i8** %o5, align 8
  %11 = ptrtoint i8* %10 to i64
  %and6 = and i64 %11, 4222124650659840
  %shr = lshr i64 %and6, 48
  %mul = mul i64 %conv4, %shr
  %cmp7 = icmp eq i64 %mul, 5
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %o9 = bitcast %union.UnionType* %pkg to i8**
  %12 = load i8** %o9, align 8
  %13 = ptrtoint i8* %12 to i64
  %xor10 = xor i64 %13, -3096224743817216
  %14 = inttoptr i64 %xor10 to %struct._Hash*
  store %struct._Hash* %14, %struct._Hash** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call11 = call i8* @calloc(i64 32, i64 1)
  %15 = bitcast i8* %call11 to %struct._Hash*
  store %struct._Hash* %15, %struct._Hash** %hash, align 8
  %call12 = call i8* @calloc(i64 8, i64 512)
  %16 = bitcast i8* %call12 to %union.UnionType*
  %17 = load %struct._Hash** %hash, align 8
  %table = getelementptr inbounds %struct._Hash* %17, i32 0, i32 1
  store %union.UnionType* %16, %union.UnionType** %table, align 8
  %18 = load %struct._Hash** %hash, align 8
  %table13 = getelementptr inbounds %struct._Hash* %18, i32 0, i32 1
  %19 = load %union.UnionType** %table13, align 8
  %20 = bitcast %union.UnionType* %19 to i8*
  %21 = call i64 @llvm.objectsize.i64(i8* %20, i1 false)
  %cmp14 = icmp ne i64 %21, -1
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %22 = load %struct._Hash** %hash, align 8
  %table16 = getelementptr inbounds %struct._Hash* %22, i32 0, i32 1
  %23 = load %union.UnionType** %table16, align 8
  %24 = bitcast %union.UnionType* %23 to i8*
  %25 = load %union.UnionType** @base_hash_table, align 8
  %26 = bitcast %union.UnionType* %25 to i8*
  %27 = load %struct._Hash** %hash, align 8
  %table17 = getelementptr inbounds %struct._Hash* %27, i32 0, i32 1
  %28 = load %union.UnionType** %table17, align 8
  %29 = bitcast %union.UnionType* %28 to i8*
  %30 = call i64 @llvm.objectsize.i64(i8* %29, i1 false)
  %call18 = call i8* @__memcpy_chk(i8* %24, i8* %26, i64 4096, i64 %30) #1
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %31 = load %struct._Hash** %hash, align 8
  %table19 = getelementptr inbounds %struct._Hash* %31, i32 0, i32 1
  %32 = load %union.UnionType** %table19, align 8
  %33 = bitcast %union.UnionType* %32 to i8*
  %34 = load %union.UnionType** @base_hash_table, align 8
  %35 = bitcast %union.UnionType* %34 to i8*
  %call20 = call i8* @__inline_memcpy_chk(i8* %33, i8* %35, i64 4096)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call18, %cond.true ], [ %call20, %cond.false ]
  %call21 = call i8* @calloc(i64 8, i64 512)
  %36 = bitcast i8* %call21 to %struct._String**
  %37 = load %struct._Hash** %hash, align 8
  %keys = getelementptr inbounds %struct._Hash* %37, i32 0, i32 2
  store %struct._String** %36, %struct._String*** %keys, align 8
  %38 = load %struct._Hash** %hash, align 8
  %39 = ptrtoint %struct._Hash* %38 to i64
  %or = or i64 %39, -4503599627370496
  %or22 = or i64 %or, 1407374883553280
  %40 = inttoptr i64 %or22 to i8*
  %o23 = bitcast %union.UnionType* %value to i8**
  store i8* %40, i8** %o23, align 8
  %41 = load %struct._Hash** @pkg_map, align 8
  %42 = load %struct._String** %key, align 8
  %coerce.dive24 = getelementptr %union.UnionType* %value, i32 0, i32 0
  %43 = bitcast double* %coerce.dive24 to i64*
  %44 = load i64* %43, align 1
  call void @Hash_add(%struct._Hash* %41, %struct._String* %42, i64 %44)
  %45 = load %struct._Hash** %hash, align 8
  store %struct._Hash* %45, %struct._Hash** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %46 = load %struct._Hash** %retval
  ret %struct._Hash* %46
}

; Function Attrs: nounwind ssp uwtable
define void @store_method_by_pkg_name(i8* %pkg_name, i8* %mtd_name, i64 (%struct._Array*)* %code) #0 {
entry:
  %pkg_name.addr = alloca i8*, align 8
  %mtd_name.addr = alloca i8*, align 8
  %code.addr = alloca i64 (%struct._Array*)*, align 8
  %pkg = alloca %struct._Hash*, align 8
  %_mtd_name = alloca %union.UnionType, align 8
  %o = alloca %struct._CodeRef*, align 8
  %code_ref = alloca %union.UnionType, align 8
  store i8* %pkg_name, i8** %pkg_name.addr, align 8
  store i8* %mtd_name, i8** %mtd_name.addr, align 8
  store i64 (%struct._Array*)* %code, i64 (%struct._Array*)** %code.addr, align 8
  %0 = load i8** %pkg_name.addr, align 8
  %call = call %struct._Hash* @get_pkg(i8* %0)
  store %struct._Hash* %call, %struct._Hash** %pkg, align 8
  %1 = load i8** %mtd_name.addr, align 8
  %call1 = call i64 @new_String(i8* %1)
  %coerce.dive = getelementptr %union.UnionType* %_mtd_name, i32 0, i32 0
  %2 = bitcast double* %coerce.dive to i64*
  store i64 %call1, i64* %2, align 1
  %call2 = call i8* @calloc(i64 16, i64 1)
  %3 = bitcast i8* %call2 to %struct._CodeRef*
  store %struct._CodeRef* %3, %struct._CodeRef** %o, align 8
  %4 = load i64 (%struct._Array*)** %code.addr, align 8
  %5 = load %struct._CodeRef** %o, align 8
  %code3 = getelementptr inbounds %struct._CodeRef* %5, i32 0, i32 1
  store i64 (%struct._Array*)* %4, i64 (%struct._Array*)** %code3, align 8
  %6 = load %struct._CodeRef** %o, align 8
  %7 = ptrtoint %struct._CodeRef* %6 to i64
  %or = or i64 %7, -4503599627370496
  %or4 = or i64 %or, 2533274790395904
  %8 = inttoptr i64 %or4 to i8*
  %o5 = bitcast %union.UnionType* %code_ref to i8**
  store i8* %8, i8** %o5, align 8
  %9 = load %struct._Hash** %pkg, align 8
  %o6 = bitcast %union.UnionType* %_mtd_name to i8**
  %10 = load i8** %o6, align 8
  %11 = ptrtoint i8* %10 to i64
  %xor = xor i64 %11, -3940649673949184
  %12 = inttoptr i64 %xor to %struct._String*
  %coerce.dive7 = getelementptr %union.UnionType* %code_ref, i32 0, i32 0
  %13 = bitcast double* %coerce.dive7 to i64*
  %14 = load i64* %13, align 1
  call void @Hash_add(%struct._Hash* %9, %struct._String* %12, i64 %14)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define i64 (%struct._Array*)* @get_method_by_name(%struct._BlessedObject* %self, i8* %mtd_name) #0 {
entry:
  %self.addr = alloca %struct._BlessedObject*, align 8
  %mtd_name.addr = alloca i8*, align 8
  %mtds = alloca %struct._Hash*, align 8
  %str = alloca %union.UnionType, align 8
  %s = alloca %struct._String*, align 8
  %mtd = alloca %union.UnionType, align 8
  %code_ref = alloca %struct._CodeRef*, align 8
  store %struct._BlessedObject* %self, %struct._BlessedObject** %self.addr, align 8
  store i8* %mtd_name, i8** %mtd_name.addr, align 8
  %0 = load %struct._BlessedObject** %self.addr, align 8
  %mtds1 = getelementptr inbounds %struct._BlessedObject* %0, i32 0, i32 2
  %1 = load %struct._Hash** %mtds1, align 8
  store %struct._Hash* %1, %struct._Hash** %mtds, align 8
  %2 = load i8** %mtd_name.addr, align 8
  %call = call i64 @new_String(i8* %2)
  %coerce.dive = getelementptr %union.UnionType* %str, i32 0, i32 0
  %3 = bitcast double* %coerce.dive to i64*
  store i64 %call, i64* %3, align 1
  %o = bitcast %union.UnionType* %str to i8**
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %xor = xor i64 %5, -3940649673949184
  %6 = inttoptr i64 %xor to %struct._String*
  store %struct._String* %6, %struct._String** %s, align 8
  %7 = load %struct._String** %s, align 8
  %hash = getelementptr inbounds %struct._String* %7, i32 0, i32 3
  %8 = load i64* %hash, align 8
  %9 = load %struct._Hash** %mtds, align 8
  %table = getelementptr inbounds %struct._Hash* %9, i32 0, i32 1
  %10 = load %union.UnionType** %table, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %10, i64 %8
  %11 = bitcast %union.UnionType* %mtd to i8*
  %12 = bitcast %union.UnionType* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %entry
  %o2 = bitcast %union.UnionType* %mtd to i8**
  %13 = load i8** %o2, align 8
  %14 = ptrtoint i8* %13 to i64
  %and = and i64 %14, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv3 = sext i32 %conv to i64
  %o4 = bitcast %union.UnionType* %mtd to i8**
  %15 = load i8** %o4, align 8
  %16 = ptrtoint i8* %15 to i64
  %and5 = and i64 %16, 4222124650659840
  %shr = lshr i64 %and5, 48
  %mul = mul i64 %conv3, %shr
  %cmp6 = icmp ne i64 %mul, 9
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([19 x i8]* @__func__.get_method_by_name, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 433, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %o8 = bitcast %union.UnionType* %mtd to i8**
  %17 = load i8** %o8, align 8
  %18 = ptrtoint i8* %17 to i64
  %xor9 = xor i64 %18, -1970324836974592
  %19 = inttoptr i64 %xor9 to %struct._CodeRef*
  store %struct._CodeRef* %19, %struct._CodeRef** %code_ref, align 8
  %20 = load %struct._CodeRef** %code_ref, align 8
  %code = getelementptr inbounds %struct._CodeRef* %20, i32 0, i32 1
  %21 = load i64 (%struct._Array*)** %code, align 8
  ret i64 (%struct._Array*)* %21
}

; Function Attrs: nounwind ssp uwtable
define i64 @new_Hash(%struct._Array* %array) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %array.addr = alloca %struct._Array*, align 8
  %ret = alloca %union.UnionType, align 8
  %hash = alloca %struct._Hash*, align 8
  %size = alloca i64, align 8
  %key_n = alloca i32, align 4
  %i = alloca i64, align 8
  %list = alloca %union.UnionType*, align 8
  %key = alloca %struct._String*, align 8
  %value = alloca %union.UnionType, align 8
  %o20 = alloca %struct._Object*, align 8
  store %struct._Array* %array, %struct._Array** %array.addr, align 8
  %call = call i8* @calloc(i64 32, i64 1)
  %0 = bitcast i8* %call to %struct._Hash*
  store %struct._Hash* %0, %struct._Hash** %hash, align 8
  %call1 = call i8* @calloc(i64 8, i64 512)
  %1 = bitcast i8* %call1 to %union.UnionType*
  %2 = load %struct._Hash** %hash, align 8
  %table = getelementptr inbounds %struct._Hash* %2, i32 0, i32 1
  store %union.UnionType* %1, %union.UnionType** %table, align 8
  %3 = load %struct._Hash** %hash, align 8
  %table2 = getelementptr inbounds %struct._Hash* %3, i32 0, i32 1
  %4 = load %union.UnionType** %table2, align 8
  %5 = bitcast %union.UnionType* %4 to i8*
  %6 = call i64 @llvm.objectsize.i64(i8* %5, i1 false)
  %cmp = icmp ne i64 %6, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load %struct._Hash** %hash, align 8
  %table3 = getelementptr inbounds %struct._Hash* %7, i32 0, i32 1
  %8 = load %union.UnionType** %table3, align 8
  %9 = bitcast %union.UnionType* %8 to i8*
  %10 = load %union.UnionType** @base_hash_table, align 8
  %11 = bitcast %union.UnionType* %10 to i8*
  %12 = load %struct._Hash** %hash, align 8
  %table4 = getelementptr inbounds %struct._Hash* %12, i32 0, i32 1
  %13 = load %union.UnionType** %table4, align 8
  %14 = bitcast %union.UnionType* %13 to i8*
  %15 = call i64 @llvm.objectsize.i64(i8* %14, i1 false)
  %call5 = call i8* @__memcpy_chk(i8* %9, i8* %11, i64 4096, i64 %15) #1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %16 = load %struct._Hash** %hash, align 8
  %table6 = getelementptr inbounds %struct._Hash* %16, i32 0, i32 1
  %17 = load %union.UnionType** %table6, align 8
  %18 = bitcast %union.UnionType* %17 to i8*
  %19 = load %union.UnionType** @base_hash_table, align 8
  %20 = bitcast %union.UnionType* %19 to i8*
  %call7 = call i8* @__inline_memcpy_chk(i8* %18, i8* %20, i64 4096)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call5, %cond.true ], [ %call7, %cond.false ]
  %call8 = call i8* @calloc(i64 8, i64 512)
  %21 = bitcast i8* %call8 to %struct._String**
  %22 = load %struct._Hash** %hash, align 8
  %keys = getelementptr inbounds %struct._Hash* %22, i32 0, i32 2
  store %struct._String** %21, %struct._String*** %keys, align 8
  %23 = load %struct._Array** %array.addr, align 8
  %size9 = getelementptr inbounds %struct._Array* %23, i32 0, i32 2
  %24 = load i64* %size9, align 8
  store i64 %24, i64* %size, align 8
  store i32 0, i32* %key_n, align 4
  store i64 0, i64* %i, align 8
  %25 = load %struct._Array** %array.addr, align 8
  %list10 = getelementptr inbounds %struct._Array* %25, i32 0, i32 1
  %26 = load %union.UnionType** %list10, align 8
  store %union.UnionType* %26, %union.UnionType** %list, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %27 = load i64* %i, align 8
  %28 = load i64* %size, align 8
  %cmp11 = icmp ult i64 %27, %28
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load i64* %i, align 8
  %30 = load %union.UnionType** %list, align 8
  %arrayidx = getelementptr inbounds %union.UnionType* %30, i64 %29
  %o = bitcast %union.UnionType* %arrayidx to i8**
  %31 = load i8** %o, align 8
  %32 = ptrtoint i8* %31 to i64
  %xor = xor i64 %32, -3940649673949184
  %33 = inttoptr i64 %xor to %struct._String*
  store %struct._String* %33, %struct._String** %key, align 8
  %34 = load i64* %i, align 8
  %add = add i64 %34, 1
  %35 = load %union.UnionType** %list, align 8
  %arrayidx12 = getelementptr inbounds %union.UnionType* %35, i64 %add
  %36 = bitcast %union.UnionType* %value to i8*
  %37 = bitcast %union.UnionType* %arrayidx12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %36, i8* %37, i64 8, i32 8, i1 false)
  %o13 = bitcast %union.UnionType* %value to i8**
  %38 = load i8** %o13, align 8
  %39 = ptrtoint i8* %38 to i64
  %and = and i64 %39, -4503599627370496
  %cmp14 = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp14 to i32
  %conv15 = sext i32 %conv to i64
  %o16 = bitcast %union.UnionType* %value to i8**
  %40 = load i8** %o16, align 8
  %41 = ptrtoint i8* %40 to i64
  %and17 = and i64 %41, 4222124650659840
  %shr = lshr i64 %and17, 48
  %mul = mul i64 %conv15, %shr
  %cmp18 = icmp eq i64 %mul, 7
  br i1 %cmp18, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %o21 = bitcast %union.UnionType* %value to i8**
  %42 = load i8** %o21, align 8
  %43 = ptrtoint i8* %42 to i64
  %xor22 = xor i64 %43, -2533274790395904
  %44 = inttoptr i64 %xor22 to %struct._Object*
  store %struct._Object* %44, %struct._Object** %o20, align 8
  %45 = load %struct._Object** %o20, align 8
  %v = getelementptr inbounds %struct._Object* %45, i32 0, i32 1
  %46 = bitcast %union.UnionType* %value to i8*
  %47 = bitcast %union.UnionType* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %46, i8* %47, i64 8, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %o23 = bitcast %union.UnionType* %value to i8**
  %48 = load i8** %o23, align 8
  %49 = ptrtoint i8* %48 to i64
  %and24 = and i64 %49, -4503599627370496
  %cmp25 = icmp eq i64 %and24, -4503599627370496
  %conv26 = zext i1 %cmp25 to i32
  %conv27 = sext i32 %conv26 to i64
  %o28 = bitcast %union.UnionType* %value to i8**
  %50 = load i8** %o28, align 8
  %51 = ptrtoint i8* %50 to i64
  %and29 = and i64 %51, 4222124650659840
  %shr30 = lshr i64 %and29, 48
  %mul31 = mul i64 %conv27, %shr30
  %cmp32 = icmp eq i64 %mul31, 0
  br i1 %cmp32, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end
  %d = bitcast %union.UnionType* %value to double*
  %52 = load double* %d, align 8
  %53 = load %struct._String** %key, align 8
  %hash35 = getelementptr inbounds %struct._String* %53, i32 0, i32 3
  %54 = load i64* %hash35, align 8
  %55 = load %struct._Hash** %hash, align 8
  %table36 = getelementptr inbounds %struct._Hash* %55, i32 0, i32 1
  %56 = load %union.UnionType** %table36, align 8
  %arrayidx37 = getelementptr inbounds %union.UnionType* %56, i64 %54
  %d38 = bitcast %union.UnionType* %arrayidx37 to double*
  store double %52, double* %d38, align 8
  br label %if.end44

if.else:                                          ; preds = %if.end
  %o39 = bitcast %union.UnionType* %value to i8**
  %57 = load i8** %o39, align 8
  %58 = load %struct._String** %key, align 8
  %hash40 = getelementptr inbounds %struct._String* %58, i32 0, i32 3
  %59 = load i64* %hash40, align 8
  %60 = load %struct._Hash** %hash, align 8
  %table41 = getelementptr inbounds %struct._Hash* %60, i32 0, i32 1
  %61 = load %union.UnionType** %table41, align 8
  %arrayidx42 = getelementptr inbounds %union.UnionType* %61, i64 %59
  %o43 = bitcast %union.UnionType* %arrayidx42 to i8**
  store i8* %57, i8** %o43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.then34
  %62 = load %struct._String** %key, align 8
  %63 = load i32* %key_n, align 4
  %idxprom = sext i32 %63 to i64
  %64 = load %struct._Hash** %hash, align 8
  %keys45 = getelementptr inbounds %struct._Hash* %64, i32 0, i32 2
  %65 = load %struct._String*** %keys45, align 8
  %arrayidx46 = getelementptr inbounds %struct._String** %65, i64 %idxprom
  store %struct._String* %62, %struct._String** %arrayidx46, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end44
  %66 = load i64* %i, align 8
  %add47 = add i64 %66, 2
  store i64 %add47, i64* %i, align 8
  %67 = load i32* %key_n, align 4
  %inc = add nsw i32 %67, 1
  store i32 %inc, i32* %key_n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %68 = load i32* %key_n, align 4
  %conv48 = sext i32 %68 to i64
  %69 = load %struct._Hash** %hash, align 8
  %size49 = getelementptr inbounds %struct._Hash* %69, i32 0, i32 3
  store i64 %conv48, i64* %size49, align 8
  %70 = load %struct._Hash** %hash, align 8
  %71 = ptrtoint %struct._Hash* %70 to i64
  %or = or i64 %71, -4503599627370496
  %or50 = or i64 %or, 1407374883553280
  %72 = inttoptr i64 %or50 to i8*
  %o51 = bitcast %union.UnionType* %ret to i8**
  store i8* %72, i8** %o51, align 8
  %73 = bitcast %union.UnionType* %retval to i8*
  %74 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %73, i8* %74, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %75 = bitcast double* %coerce.dive to i64*
  %76 = load i64* %75, align 1
  ret i64 %76
}

; Function Attrs: nounwind ssp uwtable
define i64 @Hash_to_array(%struct._Hash* %hash) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %hash.addr = alloca %struct._Hash*, align 8
  %ret = alloca %union.UnionType, align 8
  %array = alloca %struct._Array*, align 8
  %key_n = alloca i64, align 8
  %array_size = alloca i64, align 8
  %i = alloca i64, align 8
  %key = alloca %struct._String*, align 8
  %boxed_key = alloca %union.UnionType, align 8
  store %struct._Hash* %hash, %struct._Hash** %hash.addr, align 8
  %call = call i8* @calloc(i64 24, i64 1)
  %0 = bitcast i8* %call to %struct._Array*
  store %struct._Array* %0, %struct._Array** %array, align 8
  %1 = load %struct._Hash** %hash.addr, align 8
  %size = getelementptr inbounds %struct._Hash* %1, i32 0, i32 3
  %2 = load i64* %size, align 8
  store i64 %2, i64* %key_n, align 8
  %3 = load i64* %key_n, align 8
  %mul = mul i64 %3, 2
  store i64 %mul, i64* %array_size, align 8
  %4 = load i64* %array_size, align 8
  %call1 = call i8* @calloc(i64 8, i64 %4)
  %5 = bitcast i8* %call1 to %union.UnionType*
  %6 = load %struct._Array** %array, align 8
  %list = getelementptr inbounds %struct._Array* %6, i32 0, i32 1
  store %union.UnionType* %5, %union.UnionType** %list, align 8
  %7 = load i64* %array_size, align 8
  %8 = load %struct._Array** %array, align 8
  %size2 = getelementptr inbounds %struct._Array* %8, i32 0, i32 2
  store i64 %7, i64* %size2, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i64* %i, align 8
  %10 = load i64* %key_n, align 8
  %cmp = icmp ult i64 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i64* %i, align 8
  %12 = load %struct._Hash** %hash.addr, align 8
  %keys = getelementptr inbounds %struct._Hash* %12, i32 0, i32 2
  %13 = load %struct._String*** %keys, align 8
  %arrayidx = getelementptr inbounds %struct._String** %13, i64 %11
  %14 = load %struct._String** %arrayidx, align 8
  store %struct._String* %14, %struct._String** %key, align 8
  %15 = load %struct._String** %key, align 8
  %16 = ptrtoint %struct._String* %15 to i64
  %or = or i64 %16, -4503599627370496
  %or3 = or i64 %or, 562949953421312
  %17 = inttoptr i64 %or3 to i8*
  %o = bitcast %union.UnionType* %boxed_key to i8**
  store i8* %17, i8** %o, align 8
  %18 = load i64* %i, align 8
  %mul4 = mul i64 %18, 2
  %19 = load %struct._Array** %array, align 8
  %list5 = getelementptr inbounds %struct._Array* %19, i32 0, i32 1
  %20 = load %union.UnionType** %list5, align 8
  %arrayidx6 = getelementptr inbounds %union.UnionType* %20, i64 %mul4
  %21 = bitcast %union.UnionType* %arrayidx6 to i8*
  %22 = bitcast %union.UnionType* %boxed_key to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 8, i32 8, i1 false)
  %23 = load i64* %i, align 8
  %mul7 = mul i64 %23, 2
  %add = add i64 %mul7, 1
  %24 = load %struct._Array** %array, align 8
  %list8 = getelementptr inbounds %struct._Array* %24, i32 0, i32 1
  %25 = load %union.UnionType** %list8, align 8
  %arrayidx9 = getelementptr inbounds %union.UnionType* %25, i64 %add
  %26 = load %struct._String** %key, align 8
  %hash10 = getelementptr inbounds %struct._String* %26, i32 0, i32 3
  %27 = load i64* %hash10, align 8
  %28 = load %struct._Hash** %hash.addr, align 8
  %table = getelementptr inbounds %struct._Hash* %28, i32 0, i32 1
  %29 = load %union.UnionType** %table, align 8
  %arrayidx11 = getelementptr inbounds %union.UnionType* %29, i64 %27
  %30 = bitcast %union.UnionType* %arrayidx9 to i8*
  %31 = bitcast %union.UnionType* %arrayidx11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %32 = load i64* %i, align 8
  %inc = add i64 %32, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %33 = load %struct._Array** %array, align 8
  %34 = ptrtoint %struct._Array* %33 to i64
  %or12 = or i64 %34, -4503599627370496
  %or13 = or i64 %or12, 844424930131968
  %35 = inttoptr i64 %or13 to i8*
  %o14 = bitcast %union.UnionType* %ret to i8**
  store i8* %35, i8** %o14, align 8
  %36 = bitcast %union.UnionType* %retval to i8*
  %37 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %36, i8* %37, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %38 = bitcast double* %coerce.dive to i64*
  %39 = load i64* %38, align 1
  ret i64 %39
}

; Function Attrs: nounwind ssp uwtable
define %struct._HashRef* @dynamic_hash_ref_cast_code(%union.UnionType* %o) #0 {
entry:
  %o.addr = alloca %union.UnionType*, align 8
  %ret = alloca %struct._HashRef*, align 8
  %object = alloca %struct._Object*, align 8
  %blessed = alloca %struct._BlessedObject*, align 8
  store %union.UnionType* %o, %union.UnionType** %o.addr, align 8
  store %struct._HashRef* null, %struct._HashRef** %ret, align 8
  %0 = load %union.UnionType** %o.addr, align 8
  %o1 = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o1, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv2 = sext i32 %conv to i64
  %3 = load %union.UnionType** %o.addr, align 8
  %o3 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o3, align 8
  %5 = ptrtoint i8* %4 to i64
  %and4 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and4, 48
  %mul = mul i64 %conv2, %shr
  switch i64 %mul, label %sw.default [
    i64 6, label %sw.bb
    i64 7, label %sw.bb6
    i64 8, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %union.UnionType** %o.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %xor = xor i64 %8, -2814749767106560
  %9 = inttoptr i64 %xor to %struct._HashRef*
  store %struct._HashRef* %9, %struct._HashRef** %ret, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %10 = load %union.UnionType** %o.addr, align 8
  %o7 = bitcast %union.UnionType* %10 to i8**
  %11 = load i8** %o7, align 8
  %12 = ptrtoint i8* %11 to i64
  %xor8 = xor i64 %12, -2533274790395904
  %13 = inttoptr i64 %xor8 to %struct._Object*
  store %struct._Object* %13, %struct._Object** %object, align 8
  %14 = load %struct._Object** %object, align 8
  %v = getelementptr inbounds %struct._Object* %14, i32 0, i32 1
  %call = call %struct._HashRef* @dynamic_hash_ref_cast_code(%union.UnionType* %v)
  store %struct._HashRef* %call, %struct._HashRef** %ret, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %15 = load %union.UnionType** %o.addr, align 8
  %o10 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o10, align 8
  %17 = ptrtoint i8* %16 to i64
  %xor11 = xor i64 %17, -2251799813685248
  %18 = inttoptr i64 %xor11 to %struct._BlessedObject*
  store %struct._BlessedObject* %18, %struct._BlessedObject** %blessed, align 8
  %19 = load %struct._BlessedObject** %blessed, align 8
  %members = getelementptr inbounds %struct._BlessedObject* %19, i32 0, i32 1
  %o12 = bitcast %union.UnionType* %members to i8**
  %20 = load i8** %o12, align 8
  %21 = ptrtoint i8* %20 to i64
  %xor13 = xor i64 %21, -2814749767106560
  %22 = inttoptr i64 %xor13 to %struct._HashRef*
  store %struct._HashRef* %22, %struct._HashRef** %ret, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %23 = load %struct.__sFILE** @__stderrp, align 8
  %24 = load %union.UnionType** %o.addr, align 8
  %o14 = bitcast %union.UnionType* %24 to i8**
  %25 = load i8** %o14, align 8
  %26 = ptrtoint i8* %25 to i64
  %and15 = and i64 %26, -4503599627370496
  %cmp16 = icmp eq i64 %and15, -4503599627370496
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = sext i32 %conv17 to i64
  %27 = load %union.UnionType** %o.addr, align 8
  %o19 = bitcast %union.UnionType* %27 to i8**
  %28 = load i8** %o19, align 8
  %29 = ptrtoint i8* %28 to i64
  %and20 = and i64 %29, 4222124650659840
  %shr21 = lshr i64 %and20, 48
  %mul22 = mul i64 %conv18, %shr21
  %call23 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %23, i8* getelementptr inbounds ([15 x i8]* @.str17, i32 0, i32 0), i64 %mul22)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb6, %sw.bb
  %30 = load %struct._HashRef** %ret, align 8
  ret %struct._HashRef* %30
}

; Function Attrs: nounwind ssp uwtable
define %struct._ArrayRef* @dynamic_array_ref_cast_code(%union.UnionType* %o) #0 {
entry:
  %o.addr = alloca %union.UnionType*, align 8
  %ret = alloca %struct._ArrayRef*, align 8
  %object = alloca %struct._Object*, align 8
  store %union.UnionType* %o, %union.UnionType** %o.addr, align 8
  store %struct._ArrayRef* null, %struct._ArrayRef** %ret, align 8
  %0 = load %union.UnionType** %o.addr, align 8
  %o1 = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o1, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv2 = sext i32 %conv to i64
  %3 = load %union.UnionType** %o.addr, align 8
  %o3 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o3, align 8
  %5 = ptrtoint i8* %4 to i64
  %and4 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and4, 48
  %mul = mul i64 %conv2, %shr
  switch i64 %mul, label %sw.default [
    i64 4, label %sw.bb
    i64 7, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %union.UnionType** %o.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %xor = xor i64 %8, -3377699720527872
  %9 = inttoptr i64 %xor to %struct._ArrayRef*
  store %struct._ArrayRef* %9, %struct._ArrayRef** %ret, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %10 = load %union.UnionType** %o.addr, align 8
  %o7 = bitcast %union.UnionType* %10 to i8**
  %11 = load i8** %o7, align 8
  %12 = ptrtoint i8* %11 to i64
  %xor8 = xor i64 %12, -2533274790395904
  %13 = inttoptr i64 %xor8 to %struct._Object*
  store %struct._Object* %13, %struct._Object** %object, align 8
  %14 = load %struct._Object** %object, align 8
  %v = getelementptr inbounds %struct._Object* %14, i32 0, i32 1
  %call = call %struct._ArrayRef* @dynamic_array_ref_cast_code(%union.UnionType* %v)
  store %struct._ArrayRef* %call, %struct._ArrayRef** %ret, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %15 = load %struct.__sFILE** @__stderrp, align 8
  %16 = load %union.UnionType** %o.addr, align 8
  %o9 = bitcast %union.UnionType* %16 to i8**
  %17 = load i8** %o9, align 8
  %18 = ptrtoint i8* %17 to i64
  %and10 = and i64 %18, -4503599627370496
  %cmp11 = icmp eq i64 %and10, -4503599627370496
  %conv12 = zext i1 %cmp11 to i32
  %conv13 = sext i32 %conv12 to i64
  %19 = load %union.UnionType** %o.addr, align 8
  %o14 = bitcast %union.UnionType* %19 to i8**
  %20 = load i8** %o14, align 8
  %21 = ptrtoint i8* %20 to i64
  %and15 = and i64 %21, 4222124650659840
  %shr16 = lshr i64 %and15, 48
  %mul17 = mul i64 %conv13, %shr16
  %call18 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %15, i8* getelementptr inbounds ([15 x i8]* @.str17, i32 0, i32 0), i64 %mul17)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb
  %22 = load %struct._ArrayRef** %ret, align 8
  ret %struct._ArrayRef* %22
}

; Function Attrs: nounwind ssp uwtable
define %struct._BlessedObject* @dynamic_blessed_object_cast_code(%union.UnionType* %o) #0 {
entry:
  %o.addr = alloca %union.UnionType*, align 8
  %ret = alloca %struct._BlessedObject*, align 8
  %object = alloca %struct._Object*, align 8
  store %union.UnionType* %o, %union.UnionType** %o.addr, align 8
  store %struct._BlessedObject* null, %struct._BlessedObject** %ret, align 8
  %0 = load %union.UnionType** %o.addr, align 8
  %o1 = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o1, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv2 = sext i32 %conv to i64
  %3 = load %union.UnionType** %o.addr, align 8
  %o3 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o3, align 8
  %5 = ptrtoint i8* %4 to i64
  %and4 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and4, 48
  %mul = mul i64 %conv2, %shr
  switch i64 %mul, label %sw.default [
    i64 7, label %sw.bb
    i64 8, label %sw.bb21
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %union.UnionType** %o.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %xor = xor i64 %8, -2533274790395904
  %9 = inttoptr i64 %xor to %struct._Object*
  store %struct._Object* %9, %struct._Object** %object, align 8
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %10 = load %struct._Object** %object, align 8
  %v = getelementptr inbounds %struct._Object* %10, i32 0, i32 1
  %o6 = bitcast %union.UnionType* %v to i8**
  %11 = load i8** %o6, align 8
  %12 = ptrtoint i8* %11 to i64
  %and7 = and i64 %12, -4503599627370496
  %cmp8 = icmp eq i64 %and7, -4503599627370496
  %conv9 = zext i1 %cmp8 to i32
  %conv10 = sext i32 %conv9 to i64
  %13 = load %struct._Object** %object, align 8
  %v11 = getelementptr inbounds %struct._Object* %13, i32 0, i32 1
  %o12 = bitcast %union.UnionType* %v11 to i8**
  %14 = load i8** %o12, align 8
  %15 = ptrtoint i8* %14 to i64
  %and13 = and i64 %15, 4222124650659840
  %shr14 = lshr i64 %and13, 48
  %mul15 = mul i64 %conv10, %shr14
  %cmp16 = icmp ne i64 %mul15, 8
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([33 x i8]* @__func__.dynamic_blessed_object_cast_code, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str, i32 0, i32 0), i32 545, i8* getelementptr inbounds ([21 x i8]* @.str12, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %16 = load %struct._Object** %object, align 8
  %v18 = getelementptr inbounds %struct._Object* %16, i32 0, i32 1
  %o19 = bitcast %union.UnionType* %v18 to i8**
  %17 = load i8** %o19, align 8
  %18 = ptrtoint i8* %17 to i64
  %xor20 = xor i64 %18, -2251799813685248
  %19 = inttoptr i64 %xor20 to %struct._BlessedObject*
  store %struct._BlessedObject* %19, %struct._BlessedObject** %ret, align 8
  br label %sw.epilog

sw.bb21:                                          ; preds = %entry
  %20 = load %union.UnionType** %o.addr, align 8
  %o22 = bitcast %union.UnionType* %20 to i8**
  %21 = load i8** %o22, align 8
  %22 = ptrtoint i8* %21 to i64
  %xor23 = xor i64 %22, -2251799813685248
  %23 = inttoptr i64 %xor23 to %struct._BlessedObject*
  store %struct._BlessedObject* %23, %struct._BlessedObject** %ret, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %24 = load %struct.__sFILE** @__stderrp, align 8
  %25 = load %union.UnionType** %o.addr, align 8
  %o24 = bitcast %union.UnionType* %25 to i8**
  %26 = load i8** %o24, align 8
  %27 = ptrtoint i8* %26 to i64
  %and25 = and i64 %27, -4503599627370496
  %cmp26 = icmp eq i64 %and25, -4503599627370496
  %conv27 = zext i1 %cmp26 to i32
  %conv28 = sext i32 %conv27 to i64
  %28 = load %union.UnionType** %o.addr, align 8
  %o29 = bitcast %union.UnionType* %28 to i8**
  %29 = load i8** %o29, align 8
  %30 = ptrtoint i8* %29 to i64
  %and30 = and i64 %30, 4222124650659840
  %shr31 = lshr i64 %and30, 48
  %mul32 = mul i64 %conv28, %shr31
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %24, i8* getelementptr inbounds ([15 x i8]* @.str17, i32 0, i32 0), i64 %mul32)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb21, %do.end
  %31 = load %struct._BlessedObject** %ret, align 8
  ret %struct._BlessedObject* %31
}

; Function Attrs: nounwind ssp uwtable
define %struct._Object* @new_Object() #0 {
entry:
  %call = call i8* @malloc(i64 64)
  %0 = bitcast i8* %call to %struct._Object*
  ret %struct._Object* %0
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_addObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %d = alloca double, align 8
  %j39 = alloca i32, align 4
  %k42 = alloca i32, align 4
  %d52 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default60 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb27
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, i32* %i, align 4
  br label %do.body6

do.body6:                                         ; preds = %sw.bb
  %9 = load %union.UnionType** %b.addr, align 8
  %o7 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o7, align 8
  %11 = ptrtoint i8* %10 to i64
  %and8 = and i64 %11, -4503599627370496
  %cmp9 = icmp eq i64 %and8, -4503599627370496
  %conv10 = zext i1 %cmp9 to i32
  %conv11 = sext i32 %conv10 to i64
  %12 = load %union.UnionType** %b.addr, align 8
  %o12 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o12, align 8
  %14 = ptrtoint i8* %13 to i64
  %and13 = and i64 %14, 4222124650659840
  %shr14 = lshr i64 %and13, 48
  %mul15 = mul i64 %conv11, %shr14
  switch i64 %mul15, label %sw.default [
    i64 1, label %sw.bb16
    i64 0, label %sw.bb22
  ]

sw.bb16:                                          ; preds = %do.body6
  %15 = load %union.UnionType** %b.addr, align 8
  %o17 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o17, align 8
  %17 = ptrtoint i8* %16 to i64
  %conv18 = trunc i64 %17 to i32
  store i32 %conv18, i32* %j, align 4
  %18 = load i32* %i, align 4
  %19 = load i32* %j, align 4
  %add = add nsw i32 %18, %19
  store i32 %add, i32* %k, align 4
  %20 = load i32* %k, align 4
  %conv19 = zext i32 %20 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %21 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %21, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body6
  %22 = load i32* %i, align 4
  %conv23 = sitofp i32 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d24 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d24, align 8
  %add25 = fadd double %conv23, %24
  store double %add25, double* %d, align 8
  %25 = load double* %d, align 8
  %d26 = bitcast %union.UnionType* %ret to double*
  store double %25, double* %d26, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body6
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb16
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog61

sw.bb27:                                          ; preds = %do.body
  br label %do.body28

do.body28:                                        ; preds = %sw.bb27
  %26 = load %union.UnionType** %b.addr, align 8
  %o29 = bitcast %union.UnionType* %26 to i8**
  %27 = load i8** %o29, align 8
  %28 = ptrtoint i8* %27 to i64
  %and30 = and i64 %28, -4503599627370496
  %cmp31 = icmp eq i64 %and30, -4503599627370496
  %conv32 = zext i1 %cmp31 to i32
  %conv33 = sext i32 %conv32 to i64
  %29 = load %union.UnionType** %b.addr, align 8
  %o34 = bitcast %union.UnionType* %29 to i8**
  %30 = load i8** %o34, align 8
  %31 = ptrtoint i8* %30 to i64
  %and35 = and i64 %31, 4222124650659840
  %shr36 = lshr i64 %and35, 48
  %mul37 = mul i64 %conv33, %shr36
  switch i64 %mul37, label %sw.default57 [
    i64 1, label %sw.bb38
    i64 0, label %sw.bb51
  ]

sw.bb38:                                          ; preds = %do.body28
  %32 = load %union.UnionType** %b.addr, align 8
  %o40 = bitcast %union.UnionType* %32 to i8**
  %33 = load i8** %o40, align 8
  %34 = ptrtoint i8* %33 to i64
  %conv41 = trunc i64 %34 to i32
  store i32 %conv41, i32* %j39, align 4
  %35 = load %union.UnionType** %a.addr, align 8
  %d43 = bitcast %union.UnionType* %35 to double*
  %36 = load double* %d43, align 8
  %37 = load i32* %j39, align 4
  %conv44 = sitofp i32 %37 to double
  %add45 = fadd double %36, %conv44
  %conv46 = fptosi double %add45 to i32
  store i32 %conv46, i32* %k42, align 4
  %38 = load i32* %k42, align 4
  %conv47 = zext i32 %38 to i64
  %or48 = or i64 %conv47, -4503599627370496
  %or49 = or i64 %or48, 281474976710656
  %39 = inttoptr i64 %or49 to i8*
  %o50 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o50, align 8
  br label %sw.epilog58

sw.bb51:                                          ; preds = %do.body28
  %40 = load %union.UnionType** %a.addr, align 8
  %d53 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d53, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d54 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d54, align 8
  %add55 = fadd double %41, %43
  store double %add55, double* %d52, align 8
  %44 = load double* %d52, align 8
  %d56 = bitcast %union.UnionType* %ret to double*
  store double %44, double* %d56, align 8
  br label %sw.epilog58

sw.default57:                                     ; preds = %do.body28
  br label %sw.epilog58

sw.epilog58:                                      ; preds = %sw.default57, %sw.bb51, %sw.bb38
  br label %do.end59

do.end59:                                         ; preds = %sw.epilog58
  br label %sw.epilog61

sw.default60:                                     ; preds = %do.body
  br label %sw.epilog61

sw.epilog61:                                      ; preds = %sw.default60, %do.end59, %do.end
  br label %do.end62

do.end62:                                         ; preds = %sw.epilog61
  %45 = bitcast %union.UnionType* %retval to i8*
  %46 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %47 = bitcast double* %coerce.dive to i64*
  %48 = load i64* %47, align 1
  ret i64 %48
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_subObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %d = alloca double, align 8
  %j39 = alloca i32, align 4
  %k42 = alloca i32, align 4
  %d52 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default60 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb27
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, i32* %i, align 4
  br label %do.body6

do.body6:                                         ; preds = %sw.bb
  %9 = load %union.UnionType** %b.addr, align 8
  %o7 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o7, align 8
  %11 = ptrtoint i8* %10 to i64
  %and8 = and i64 %11, -4503599627370496
  %cmp9 = icmp eq i64 %and8, -4503599627370496
  %conv10 = zext i1 %cmp9 to i32
  %conv11 = sext i32 %conv10 to i64
  %12 = load %union.UnionType** %b.addr, align 8
  %o12 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o12, align 8
  %14 = ptrtoint i8* %13 to i64
  %and13 = and i64 %14, 4222124650659840
  %shr14 = lshr i64 %and13, 48
  %mul15 = mul i64 %conv11, %shr14
  switch i64 %mul15, label %sw.default [
    i64 1, label %sw.bb16
    i64 0, label %sw.bb22
  ]

sw.bb16:                                          ; preds = %do.body6
  %15 = load %union.UnionType** %b.addr, align 8
  %o17 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o17, align 8
  %17 = ptrtoint i8* %16 to i64
  %conv18 = trunc i64 %17 to i32
  store i32 %conv18, i32* %j, align 4
  %18 = load i32* %i, align 4
  %19 = load i32* %j, align 4
  %sub = sub nsw i32 %18, %19
  store i32 %sub, i32* %k, align 4
  %20 = load i32* %k, align 4
  %conv19 = zext i32 %20 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %21 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %21, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body6
  %22 = load i32* %i, align 4
  %conv23 = sitofp i32 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d24 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d24, align 8
  %sub25 = fsub double %conv23, %24
  store double %sub25, double* %d, align 8
  %25 = load double* %d, align 8
  %d26 = bitcast %union.UnionType* %ret to double*
  store double %25, double* %d26, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body6
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb16
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog61

sw.bb27:                                          ; preds = %do.body
  br label %do.body28

do.body28:                                        ; preds = %sw.bb27
  %26 = load %union.UnionType** %b.addr, align 8
  %o29 = bitcast %union.UnionType* %26 to i8**
  %27 = load i8** %o29, align 8
  %28 = ptrtoint i8* %27 to i64
  %and30 = and i64 %28, -4503599627370496
  %cmp31 = icmp eq i64 %and30, -4503599627370496
  %conv32 = zext i1 %cmp31 to i32
  %conv33 = sext i32 %conv32 to i64
  %29 = load %union.UnionType** %b.addr, align 8
  %o34 = bitcast %union.UnionType* %29 to i8**
  %30 = load i8** %o34, align 8
  %31 = ptrtoint i8* %30 to i64
  %and35 = and i64 %31, 4222124650659840
  %shr36 = lshr i64 %and35, 48
  %mul37 = mul i64 %conv33, %shr36
  switch i64 %mul37, label %sw.default57 [
    i64 1, label %sw.bb38
    i64 0, label %sw.bb51
  ]

sw.bb38:                                          ; preds = %do.body28
  %32 = load %union.UnionType** %b.addr, align 8
  %o40 = bitcast %union.UnionType* %32 to i8**
  %33 = load i8** %o40, align 8
  %34 = ptrtoint i8* %33 to i64
  %conv41 = trunc i64 %34 to i32
  store i32 %conv41, i32* %j39, align 4
  %35 = load %union.UnionType** %a.addr, align 8
  %d43 = bitcast %union.UnionType* %35 to double*
  %36 = load double* %d43, align 8
  %37 = load i32* %j39, align 4
  %conv44 = sitofp i32 %37 to double
  %sub45 = fsub double %36, %conv44
  %conv46 = fptosi double %sub45 to i32
  store i32 %conv46, i32* %k42, align 4
  %38 = load i32* %k42, align 4
  %conv47 = zext i32 %38 to i64
  %or48 = or i64 %conv47, -4503599627370496
  %or49 = or i64 %or48, 281474976710656
  %39 = inttoptr i64 %or49 to i8*
  %o50 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o50, align 8
  br label %sw.epilog58

sw.bb51:                                          ; preds = %do.body28
  %40 = load %union.UnionType** %a.addr, align 8
  %d53 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d53, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d54 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d54, align 8
  %sub55 = fsub double %41, %43
  store double %sub55, double* %d52, align 8
  %44 = load double* %d52, align 8
  %d56 = bitcast %union.UnionType* %ret to double*
  store double %44, double* %d56, align 8
  br label %sw.epilog58

sw.default57:                                     ; preds = %do.body28
  br label %sw.epilog58

sw.epilog58:                                      ; preds = %sw.default57, %sw.bb51, %sw.bb38
  br label %do.end59

do.end59:                                         ; preds = %sw.epilog58
  br label %sw.epilog61

sw.default60:                                     ; preds = %do.body
  br label %sw.epilog61

sw.epilog61:                                      ; preds = %sw.default60, %do.end59, %do.end
  br label %do.end62

do.end62:                                         ; preds = %sw.epilog61
  %45 = bitcast %union.UnionType* %retval to i8*
  %46 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %47 = bitcast double* %coerce.dive to i64*
  %48 = load i64* %47, align 1
  ret i64 %48
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_mulObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %d = alloca double, align 8
  %j40 = alloca i32, align 4
  %k43 = alloca i32, align 4
  %d53 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default61 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb28
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, i32* %i, align 4
  br label %do.body6

do.body6:                                         ; preds = %sw.bb
  %9 = load %union.UnionType** %b.addr, align 8
  %o7 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o7, align 8
  %11 = ptrtoint i8* %10 to i64
  %and8 = and i64 %11, -4503599627370496
  %cmp9 = icmp eq i64 %and8, -4503599627370496
  %conv10 = zext i1 %cmp9 to i32
  %conv11 = sext i32 %conv10 to i64
  %12 = load %union.UnionType** %b.addr, align 8
  %o12 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o12, align 8
  %14 = ptrtoint i8* %13 to i64
  %and13 = and i64 %14, 4222124650659840
  %shr14 = lshr i64 %and13, 48
  %mul15 = mul i64 %conv11, %shr14
  switch i64 %mul15, label %sw.default [
    i64 1, label %sw.bb16
    i64 0, label %sw.bb23
  ]

sw.bb16:                                          ; preds = %do.body6
  %15 = load %union.UnionType** %b.addr, align 8
  %o17 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o17, align 8
  %17 = ptrtoint i8* %16 to i64
  %conv18 = trunc i64 %17 to i32
  store i32 %conv18, i32* %j, align 4
  %18 = load i32* %i, align 4
  %19 = load i32* %j, align 4
  %mul19 = mul nsw i32 %18, %19
  store i32 %mul19, i32* %k, align 4
  %20 = load i32* %k, align 4
  %conv20 = zext i32 %20 to i64
  %or = or i64 %conv20, -4503599627370496
  %or21 = or i64 %or, 281474976710656
  %21 = inttoptr i64 %or21 to i8*
  %o22 = bitcast %union.UnionType* %ret to i8**
  store i8* %21, i8** %o22, align 8
  br label %sw.epilog

sw.bb23:                                          ; preds = %do.body6
  %22 = load i32* %i, align 4
  %conv24 = sitofp i32 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d25 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d25, align 8
  %mul26 = fmul double %conv24, %24
  store double %mul26, double* %d, align 8
  %25 = load double* %d, align 8
  %d27 = bitcast %union.UnionType* %ret to double*
  store double %25, double* %d27, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body6
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb23, %sw.bb16
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog62

sw.bb28:                                          ; preds = %do.body
  br label %do.body29

do.body29:                                        ; preds = %sw.bb28
  %26 = load %union.UnionType** %b.addr, align 8
  %o30 = bitcast %union.UnionType* %26 to i8**
  %27 = load i8** %o30, align 8
  %28 = ptrtoint i8* %27 to i64
  %and31 = and i64 %28, -4503599627370496
  %cmp32 = icmp eq i64 %and31, -4503599627370496
  %conv33 = zext i1 %cmp32 to i32
  %conv34 = sext i32 %conv33 to i64
  %29 = load %union.UnionType** %b.addr, align 8
  %o35 = bitcast %union.UnionType* %29 to i8**
  %30 = load i8** %o35, align 8
  %31 = ptrtoint i8* %30 to i64
  %and36 = and i64 %31, 4222124650659840
  %shr37 = lshr i64 %and36, 48
  %mul38 = mul i64 %conv34, %shr37
  switch i64 %mul38, label %sw.default58 [
    i64 1, label %sw.bb39
    i64 0, label %sw.bb52
  ]

sw.bb39:                                          ; preds = %do.body29
  %32 = load %union.UnionType** %b.addr, align 8
  %o41 = bitcast %union.UnionType* %32 to i8**
  %33 = load i8** %o41, align 8
  %34 = ptrtoint i8* %33 to i64
  %conv42 = trunc i64 %34 to i32
  store i32 %conv42, i32* %j40, align 4
  %35 = load %union.UnionType** %a.addr, align 8
  %d44 = bitcast %union.UnionType* %35 to double*
  %36 = load double* %d44, align 8
  %37 = load i32* %j40, align 4
  %conv45 = sitofp i32 %37 to double
  %mul46 = fmul double %36, %conv45
  %conv47 = fptosi double %mul46 to i32
  store i32 %conv47, i32* %k43, align 4
  %38 = load i32* %k43, align 4
  %conv48 = zext i32 %38 to i64
  %or49 = or i64 %conv48, -4503599627370496
  %or50 = or i64 %or49, 281474976710656
  %39 = inttoptr i64 %or50 to i8*
  %o51 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o51, align 8
  br label %sw.epilog59

sw.bb52:                                          ; preds = %do.body29
  %40 = load %union.UnionType** %a.addr, align 8
  %d54 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d54, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d55 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d55, align 8
  %mul56 = fmul double %41, %43
  store double %mul56, double* %d53, align 8
  %44 = load double* %d53, align 8
  %d57 = bitcast %union.UnionType* %ret to double*
  store double %44, double* %d57, align 8
  br label %sw.epilog59

sw.default58:                                     ; preds = %do.body29
  br label %sw.epilog59

sw.epilog59:                                      ; preds = %sw.default58, %sw.bb52, %sw.bb39
  br label %do.end60

do.end60:                                         ; preds = %sw.epilog59
  br label %sw.epilog62

sw.default61:                                     ; preds = %do.body
  br label %sw.epilog62

sw.epilog62:                                      ; preds = %sw.default61, %do.end60, %do.end
  br label %do.end63

do.end63:                                         ; preds = %sw.epilog62
  %45 = bitcast %union.UnionType* %retval to i8*
  %46 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %47 = bitcast double* %coerce.dive to i64*
  %48 = load i64* %47, align 1
  ret i64 %48
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_divObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %d = alloca double, align 8
  %j39 = alloca i32, align 4
  %k42 = alloca i32, align 4
  %d52 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default60 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb27
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, i32* %i, align 4
  br label %do.body6

do.body6:                                         ; preds = %sw.bb
  %9 = load %union.UnionType** %b.addr, align 8
  %o7 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o7, align 8
  %11 = ptrtoint i8* %10 to i64
  %and8 = and i64 %11, -4503599627370496
  %cmp9 = icmp eq i64 %and8, -4503599627370496
  %conv10 = zext i1 %cmp9 to i32
  %conv11 = sext i32 %conv10 to i64
  %12 = load %union.UnionType** %b.addr, align 8
  %o12 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o12, align 8
  %14 = ptrtoint i8* %13 to i64
  %and13 = and i64 %14, 4222124650659840
  %shr14 = lshr i64 %and13, 48
  %mul15 = mul i64 %conv11, %shr14
  switch i64 %mul15, label %sw.default [
    i64 1, label %sw.bb16
    i64 0, label %sw.bb22
  ]

sw.bb16:                                          ; preds = %do.body6
  %15 = load %union.UnionType** %b.addr, align 8
  %o17 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o17, align 8
  %17 = ptrtoint i8* %16 to i64
  %conv18 = trunc i64 %17 to i32
  store i32 %conv18, i32* %j, align 4
  %18 = load i32* %i, align 4
  %19 = load i32* %j, align 4
  %div = sdiv i32 %18, %19
  store i32 %div, i32* %k, align 4
  %20 = load i32* %k, align 4
  %conv19 = zext i32 %20 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %21 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %21, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body6
  %22 = load i32* %i, align 4
  %conv23 = sitofp i32 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d24 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d24, align 8
  %div25 = fdiv double %conv23, %24
  store double %div25, double* %d, align 8
  %25 = load double* %d, align 8
  %d26 = bitcast %union.UnionType* %ret to double*
  store double %25, double* %d26, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body6
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb16
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog61

sw.bb27:                                          ; preds = %do.body
  br label %do.body28

do.body28:                                        ; preds = %sw.bb27
  %26 = load %union.UnionType** %b.addr, align 8
  %o29 = bitcast %union.UnionType* %26 to i8**
  %27 = load i8** %o29, align 8
  %28 = ptrtoint i8* %27 to i64
  %and30 = and i64 %28, -4503599627370496
  %cmp31 = icmp eq i64 %and30, -4503599627370496
  %conv32 = zext i1 %cmp31 to i32
  %conv33 = sext i32 %conv32 to i64
  %29 = load %union.UnionType** %b.addr, align 8
  %o34 = bitcast %union.UnionType* %29 to i8**
  %30 = load i8** %o34, align 8
  %31 = ptrtoint i8* %30 to i64
  %and35 = and i64 %31, 4222124650659840
  %shr36 = lshr i64 %and35, 48
  %mul37 = mul i64 %conv33, %shr36
  switch i64 %mul37, label %sw.default57 [
    i64 1, label %sw.bb38
    i64 0, label %sw.bb51
  ]

sw.bb38:                                          ; preds = %do.body28
  %32 = load %union.UnionType** %b.addr, align 8
  %o40 = bitcast %union.UnionType* %32 to i8**
  %33 = load i8** %o40, align 8
  %34 = ptrtoint i8* %33 to i64
  %conv41 = trunc i64 %34 to i32
  store i32 %conv41, i32* %j39, align 4
  %35 = load %union.UnionType** %a.addr, align 8
  %d43 = bitcast %union.UnionType* %35 to double*
  %36 = load double* %d43, align 8
  %37 = load i32* %j39, align 4
  %conv44 = sitofp i32 %37 to double
  %div45 = fdiv double %36, %conv44
  %conv46 = fptosi double %div45 to i32
  store i32 %conv46, i32* %k42, align 4
  %38 = load i32* %k42, align 4
  %conv47 = zext i32 %38 to i64
  %or48 = or i64 %conv47, -4503599627370496
  %or49 = or i64 %or48, 281474976710656
  %39 = inttoptr i64 %or49 to i8*
  %o50 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o50, align 8
  br label %sw.epilog58

sw.bb51:                                          ; preds = %do.body28
  %40 = load %union.UnionType** %a.addr, align 8
  %d53 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d53, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d54 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d54, align 8
  %div55 = fdiv double %41, %43
  store double %div55, double* %d52, align 8
  %44 = load double* %d52, align 8
  %d56 = bitcast %union.UnionType* %ret to double*
  store double %44, double* %d56, align 8
  br label %sw.epilog58

sw.default57:                                     ; preds = %do.body28
  br label %sw.epilog58

sw.epilog58:                                      ; preds = %sw.default57, %sw.bb51, %sw.bb38
  br label %do.end59

do.end59:                                         ; preds = %sw.epilog58
  br label %sw.epilog61

sw.default60:                                     ; preds = %do.body
  br label %sw.epilog61

sw.epilog61:                                      ; preds = %sw.default60, %do.end59, %do.end
  br label %do.end62

do.end62:                                         ; preds = %sw.epilog61
  %45 = bitcast %union.UnionType* %retval to i8*
  %46 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %47 = bitcast double* %coerce.dive to i64*
  %48 = load i64* %47, align 1
  ret i64 %48
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_eqObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  %i46 = alloca i32, align 4
  %d57 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default71 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb34
  ]

sw.bb:                                            ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %sw.bb
  %6 = load %union.UnionType** %b.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %and6 = and i64 %8, -4503599627370496
  %cmp7 = icmp eq i64 %and6, -4503599627370496
  %conv8 = zext i1 %cmp7 to i32
  %conv9 = sext i32 %conv8 to i64
  %9 = load %union.UnionType** %b.addr, align 8
  %o10 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o10, align 8
  %11 = ptrtoint i8* %10 to i64
  %and11 = and i64 %11, 4222124650659840
  %shr12 = lshr i64 %and11, 48
  %mul13 = mul i64 %conv9, %shr12
  switch i64 %mul13, label %sw.default [
    i64 1, label %sw.bb14
    i64 0, label %sw.bb22
  ]

sw.bb14:                                          ; preds = %do.body4
  %12 = load %union.UnionType** %a.addr, align 8
  %o15 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o15, align 8
  %14 = ptrtoint i8* %13 to i64
  %15 = load %union.UnionType** %b.addr, align 8
  %o16 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o16, align 8
  %17 = ptrtoint i8* %16 to i64
  %cmp17 = icmp eq i64 %14, %17
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, i32* %i, align 4
  %18 = load i32* %i, align 4
  %conv19 = zext i32 %18 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %19 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %19, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body4
  %20 = load %union.UnionType** %a.addr, align 8
  %o23 = bitcast %union.UnionType* %20 to i8**
  %21 = load i8** %o23, align 8
  %22 = ptrtoint i8* %21 to i64
  %conv24 = sitofp i64 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d25 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d25, align 8
  %cmp26 = fcmp oeq double %conv24, %24
  %conv27 = zext i1 %cmp26 to i32
  %conv28 = sitofp i32 %conv27 to double
  store double %conv28, double* %d, align 8
  %25 = load double* %d, align 8
  %conv29 = fptosi double %25 to i32
  %conv30 = zext i32 %conv29 to i64
  %or31 = or i64 %conv30, -4503599627370496
  %or32 = or i64 %or31, 281474976710656
  %26 = inttoptr i64 %or32 to i8*
  %o33 = bitcast %union.UnionType* %ret to i8**
  store i8* %26, i8** %o33, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb14
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog72

sw.bb34:                                          ; preds = %do.body
  br label %do.body35

do.body35:                                        ; preds = %sw.bb34
  %27 = load %union.UnionType** %b.addr, align 8
  %o36 = bitcast %union.UnionType* %27 to i8**
  %28 = load i8** %o36, align 8
  %29 = ptrtoint i8* %28 to i64
  %and37 = and i64 %29, -4503599627370496
  %cmp38 = icmp eq i64 %and37, -4503599627370496
  %conv39 = zext i1 %cmp38 to i32
  %conv40 = sext i32 %conv39 to i64
  %30 = load %union.UnionType** %b.addr, align 8
  %o41 = bitcast %union.UnionType* %30 to i8**
  %31 = load i8** %o41, align 8
  %32 = ptrtoint i8* %31 to i64
  %and42 = and i64 %32, 4222124650659840
  %shr43 = lshr i64 %and42, 48
  %mul44 = mul i64 %conv40, %shr43
  switch i64 %mul44, label %sw.default68 [
    i64 1, label %sw.bb45
    i64 0, label %sw.bb56
  ]

sw.bb45:                                          ; preds = %do.body35
  %33 = load %union.UnionType** %a.addr, align 8
  %d47 = bitcast %union.UnionType* %33 to double*
  %34 = load double* %d47, align 8
  %35 = load %union.UnionType** %b.addr, align 8
  %o48 = bitcast %union.UnionType* %35 to i8**
  %36 = load i8** %o48, align 8
  %37 = ptrtoint i8* %36 to i64
  %conv49 = sitofp i64 %37 to double
  %cmp50 = fcmp oeq double %34, %conv49
  %conv51 = zext i1 %cmp50 to i32
  store i32 %conv51, i32* %i46, align 4
  %38 = load i32* %i46, align 4
  %conv52 = zext i32 %38 to i64
  %or53 = or i64 %conv52, -4503599627370496
  %or54 = or i64 %or53, 281474976710656
  %39 = inttoptr i64 %or54 to i8*
  %o55 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o55, align 8
  br label %sw.epilog69

sw.bb56:                                          ; preds = %do.body35
  %40 = load %union.UnionType** %a.addr, align 8
  %d58 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d58, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d59 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d59, align 8
  %cmp60 = fcmp oeq double %41, %43
  %conv61 = zext i1 %cmp60 to i32
  %conv62 = sitofp i32 %conv61 to double
  store double %conv62, double* %d57, align 8
  %44 = load double* %d57, align 8
  %conv63 = fptosi double %44 to i32
  %conv64 = zext i32 %conv63 to i64
  %or65 = or i64 %conv64, -4503599627370496
  %or66 = or i64 %or65, 281474976710656
  %45 = inttoptr i64 %or66 to i8*
  %o67 = bitcast %union.UnionType* %ret to i8**
  store i8* %45, i8** %o67, align 8
  br label %sw.epilog69

sw.default68:                                     ; preds = %do.body35
  br label %sw.epilog69

sw.epilog69:                                      ; preds = %sw.default68, %sw.bb56, %sw.bb45
  br label %do.end70

do.end70:                                         ; preds = %sw.epilog69
  br label %sw.epilog72

sw.default71:                                     ; preds = %do.body
  br label %sw.epilog72

sw.epilog72:                                      ; preds = %sw.default71, %do.end70, %do.end
  br label %do.end73

do.end73:                                         ; preds = %sw.epilog72
  %46 = bitcast %union.UnionType* %retval to i8*
  %47 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %46, i8* %47, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %48 = bitcast double* %coerce.dive to i64*
  %49 = load i64* %48, align 1
  ret i64 %49
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_neObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  %i46 = alloca i32, align 4
  %d57 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default71 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb34
  ]

sw.bb:                                            ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %sw.bb
  %6 = load %union.UnionType** %b.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %and6 = and i64 %8, -4503599627370496
  %cmp7 = icmp eq i64 %and6, -4503599627370496
  %conv8 = zext i1 %cmp7 to i32
  %conv9 = sext i32 %conv8 to i64
  %9 = load %union.UnionType** %b.addr, align 8
  %o10 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o10, align 8
  %11 = ptrtoint i8* %10 to i64
  %and11 = and i64 %11, 4222124650659840
  %shr12 = lshr i64 %and11, 48
  %mul13 = mul i64 %conv9, %shr12
  switch i64 %mul13, label %sw.default [
    i64 1, label %sw.bb14
    i64 0, label %sw.bb22
  ]

sw.bb14:                                          ; preds = %do.body4
  %12 = load %union.UnionType** %a.addr, align 8
  %o15 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o15, align 8
  %14 = ptrtoint i8* %13 to i64
  %15 = load %union.UnionType** %b.addr, align 8
  %o16 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o16, align 8
  %17 = ptrtoint i8* %16 to i64
  %cmp17 = icmp ne i64 %14, %17
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, i32* %i, align 4
  %18 = load i32* %i, align 4
  %conv19 = zext i32 %18 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %19 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %19, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body4
  %20 = load %union.UnionType** %a.addr, align 8
  %o23 = bitcast %union.UnionType* %20 to i8**
  %21 = load i8** %o23, align 8
  %22 = ptrtoint i8* %21 to i64
  %conv24 = sitofp i64 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d25 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d25, align 8
  %cmp26 = fcmp une double %conv24, %24
  %conv27 = zext i1 %cmp26 to i32
  %conv28 = sitofp i32 %conv27 to double
  store double %conv28, double* %d, align 8
  %25 = load double* %d, align 8
  %conv29 = fptosi double %25 to i32
  %conv30 = zext i32 %conv29 to i64
  %or31 = or i64 %conv30, -4503599627370496
  %or32 = or i64 %or31, 281474976710656
  %26 = inttoptr i64 %or32 to i8*
  %o33 = bitcast %union.UnionType* %ret to i8**
  store i8* %26, i8** %o33, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb14
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog72

sw.bb34:                                          ; preds = %do.body
  br label %do.body35

do.body35:                                        ; preds = %sw.bb34
  %27 = load %union.UnionType** %b.addr, align 8
  %o36 = bitcast %union.UnionType* %27 to i8**
  %28 = load i8** %o36, align 8
  %29 = ptrtoint i8* %28 to i64
  %and37 = and i64 %29, -4503599627370496
  %cmp38 = icmp eq i64 %and37, -4503599627370496
  %conv39 = zext i1 %cmp38 to i32
  %conv40 = sext i32 %conv39 to i64
  %30 = load %union.UnionType** %b.addr, align 8
  %o41 = bitcast %union.UnionType* %30 to i8**
  %31 = load i8** %o41, align 8
  %32 = ptrtoint i8* %31 to i64
  %and42 = and i64 %32, 4222124650659840
  %shr43 = lshr i64 %and42, 48
  %mul44 = mul i64 %conv40, %shr43
  switch i64 %mul44, label %sw.default68 [
    i64 1, label %sw.bb45
    i64 0, label %sw.bb56
  ]

sw.bb45:                                          ; preds = %do.body35
  %33 = load %union.UnionType** %a.addr, align 8
  %d47 = bitcast %union.UnionType* %33 to double*
  %34 = load double* %d47, align 8
  %35 = load %union.UnionType** %b.addr, align 8
  %o48 = bitcast %union.UnionType* %35 to i8**
  %36 = load i8** %o48, align 8
  %37 = ptrtoint i8* %36 to i64
  %conv49 = sitofp i64 %37 to double
  %cmp50 = fcmp une double %34, %conv49
  %conv51 = zext i1 %cmp50 to i32
  store i32 %conv51, i32* %i46, align 4
  %38 = load i32* %i46, align 4
  %conv52 = zext i32 %38 to i64
  %or53 = or i64 %conv52, -4503599627370496
  %or54 = or i64 %or53, 281474976710656
  %39 = inttoptr i64 %or54 to i8*
  %o55 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o55, align 8
  br label %sw.epilog69

sw.bb56:                                          ; preds = %do.body35
  %40 = load %union.UnionType** %a.addr, align 8
  %d58 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d58, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d59 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d59, align 8
  %cmp60 = fcmp une double %41, %43
  %conv61 = zext i1 %cmp60 to i32
  %conv62 = sitofp i32 %conv61 to double
  store double %conv62, double* %d57, align 8
  %44 = load double* %d57, align 8
  %conv63 = fptosi double %44 to i32
  %conv64 = zext i32 %conv63 to i64
  %or65 = or i64 %conv64, -4503599627370496
  %or66 = or i64 %or65, 281474976710656
  %45 = inttoptr i64 %or66 to i8*
  %o67 = bitcast %union.UnionType* %ret to i8**
  store i8* %45, i8** %o67, align 8
  br label %sw.epilog69

sw.default68:                                     ; preds = %do.body35
  br label %sw.epilog69

sw.epilog69:                                      ; preds = %sw.default68, %sw.bb56, %sw.bb45
  br label %do.end70

do.end70:                                         ; preds = %sw.epilog69
  br label %sw.epilog72

sw.default71:                                     ; preds = %do.body
  br label %sw.epilog72

sw.epilog72:                                      ; preds = %sw.default71, %do.end70, %do.end
  br label %do.end73

do.end73:                                         ; preds = %sw.epilog72
  %46 = bitcast %union.UnionType* %retval to i8*
  %47 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %46, i8* %47, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %48 = bitcast double* %coerce.dive to i64*
  %49 = load i64* %48, align 1
  ret i64 %49
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_gtObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  %i46 = alloca i32, align 4
  %d57 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default71 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb34
  ]

sw.bb:                                            ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %sw.bb
  %6 = load %union.UnionType** %b.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %and6 = and i64 %8, -4503599627370496
  %cmp7 = icmp eq i64 %and6, -4503599627370496
  %conv8 = zext i1 %cmp7 to i32
  %conv9 = sext i32 %conv8 to i64
  %9 = load %union.UnionType** %b.addr, align 8
  %o10 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o10, align 8
  %11 = ptrtoint i8* %10 to i64
  %and11 = and i64 %11, 4222124650659840
  %shr12 = lshr i64 %and11, 48
  %mul13 = mul i64 %conv9, %shr12
  switch i64 %mul13, label %sw.default [
    i64 1, label %sw.bb14
    i64 0, label %sw.bb22
  ]

sw.bb14:                                          ; preds = %do.body4
  %12 = load %union.UnionType** %a.addr, align 8
  %o15 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o15, align 8
  %14 = ptrtoint i8* %13 to i64
  %15 = load %union.UnionType** %b.addr, align 8
  %o16 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o16, align 8
  %17 = ptrtoint i8* %16 to i64
  %cmp17 = icmp sgt i64 %14, %17
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, i32* %i, align 4
  %18 = load i32* %i, align 4
  %conv19 = zext i32 %18 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %19 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %19, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body4
  %20 = load %union.UnionType** %a.addr, align 8
  %o23 = bitcast %union.UnionType* %20 to i8**
  %21 = load i8** %o23, align 8
  %22 = ptrtoint i8* %21 to i64
  %conv24 = sitofp i64 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d25 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d25, align 8
  %cmp26 = fcmp ogt double %conv24, %24
  %conv27 = zext i1 %cmp26 to i32
  %conv28 = sitofp i32 %conv27 to double
  store double %conv28, double* %d, align 8
  %25 = load double* %d, align 8
  %conv29 = fptosi double %25 to i32
  %conv30 = zext i32 %conv29 to i64
  %or31 = or i64 %conv30, -4503599627370496
  %or32 = or i64 %or31, 281474976710656
  %26 = inttoptr i64 %or32 to i8*
  %o33 = bitcast %union.UnionType* %ret to i8**
  store i8* %26, i8** %o33, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb14
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog72

sw.bb34:                                          ; preds = %do.body
  br label %do.body35

do.body35:                                        ; preds = %sw.bb34
  %27 = load %union.UnionType** %b.addr, align 8
  %o36 = bitcast %union.UnionType* %27 to i8**
  %28 = load i8** %o36, align 8
  %29 = ptrtoint i8* %28 to i64
  %and37 = and i64 %29, -4503599627370496
  %cmp38 = icmp eq i64 %and37, -4503599627370496
  %conv39 = zext i1 %cmp38 to i32
  %conv40 = sext i32 %conv39 to i64
  %30 = load %union.UnionType** %b.addr, align 8
  %o41 = bitcast %union.UnionType* %30 to i8**
  %31 = load i8** %o41, align 8
  %32 = ptrtoint i8* %31 to i64
  %and42 = and i64 %32, 4222124650659840
  %shr43 = lshr i64 %and42, 48
  %mul44 = mul i64 %conv40, %shr43
  switch i64 %mul44, label %sw.default68 [
    i64 1, label %sw.bb45
    i64 0, label %sw.bb56
  ]

sw.bb45:                                          ; preds = %do.body35
  %33 = load %union.UnionType** %a.addr, align 8
  %d47 = bitcast %union.UnionType* %33 to double*
  %34 = load double* %d47, align 8
  %35 = load %union.UnionType** %b.addr, align 8
  %o48 = bitcast %union.UnionType* %35 to i8**
  %36 = load i8** %o48, align 8
  %37 = ptrtoint i8* %36 to i64
  %conv49 = sitofp i64 %37 to double
  %cmp50 = fcmp ogt double %34, %conv49
  %conv51 = zext i1 %cmp50 to i32
  store i32 %conv51, i32* %i46, align 4
  %38 = load i32* %i46, align 4
  %conv52 = zext i32 %38 to i64
  %or53 = or i64 %conv52, -4503599627370496
  %or54 = or i64 %or53, 281474976710656
  %39 = inttoptr i64 %or54 to i8*
  %o55 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o55, align 8
  br label %sw.epilog69

sw.bb56:                                          ; preds = %do.body35
  %40 = load %union.UnionType** %a.addr, align 8
  %d58 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d58, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d59 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d59, align 8
  %cmp60 = fcmp ogt double %41, %43
  %conv61 = zext i1 %cmp60 to i32
  %conv62 = sitofp i32 %conv61 to double
  store double %conv62, double* %d57, align 8
  %44 = load double* %d57, align 8
  %conv63 = fptosi double %44 to i32
  %conv64 = zext i32 %conv63 to i64
  %or65 = or i64 %conv64, -4503599627370496
  %or66 = or i64 %or65, 281474976710656
  %45 = inttoptr i64 %or66 to i8*
  %o67 = bitcast %union.UnionType* %ret to i8**
  store i8* %45, i8** %o67, align 8
  br label %sw.epilog69

sw.default68:                                     ; preds = %do.body35
  br label %sw.epilog69

sw.epilog69:                                      ; preds = %sw.default68, %sw.bb56, %sw.bb45
  br label %do.end70

do.end70:                                         ; preds = %sw.epilog69
  br label %sw.epilog72

sw.default71:                                     ; preds = %do.body
  br label %sw.epilog72

sw.epilog72:                                      ; preds = %sw.default71, %do.end70, %do.end
  br label %do.end73

do.end73:                                         ; preds = %sw.epilog72
  %46 = bitcast %union.UnionType* %retval to i8*
  %47 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %46, i8* %47, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %48 = bitcast double* %coerce.dive to i64*
  %49 = load i64* %48, align 1
  ret i64 %49
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_ltObject(%union.UnionType* %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  %i46 = alloca i32, align 4
  %d57 = alloca double, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default71 [
    i64 1, label %sw.bb
    i64 0, label %sw.bb34
  ]

sw.bb:                                            ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %sw.bb
  %6 = load %union.UnionType** %b.addr, align 8
  %o5 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o5, align 8
  %8 = ptrtoint i8* %7 to i64
  %and6 = and i64 %8, -4503599627370496
  %cmp7 = icmp eq i64 %and6, -4503599627370496
  %conv8 = zext i1 %cmp7 to i32
  %conv9 = sext i32 %conv8 to i64
  %9 = load %union.UnionType** %b.addr, align 8
  %o10 = bitcast %union.UnionType* %9 to i8**
  %10 = load i8** %o10, align 8
  %11 = ptrtoint i8* %10 to i64
  %and11 = and i64 %11, 4222124650659840
  %shr12 = lshr i64 %and11, 48
  %mul13 = mul i64 %conv9, %shr12
  switch i64 %mul13, label %sw.default [
    i64 1, label %sw.bb14
    i64 0, label %sw.bb22
  ]

sw.bb14:                                          ; preds = %do.body4
  %12 = load %union.UnionType** %a.addr, align 8
  %o15 = bitcast %union.UnionType* %12 to i8**
  %13 = load i8** %o15, align 8
  %14 = ptrtoint i8* %13 to i64
  %15 = load %union.UnionType** %b.addr, align 8
  %o16 = bitcast %union.UnionType* %15 to i8**
  %16 = load i8** %o16, align 8
  %17 = ptrtoint i8* %16 to i64
  %cmp17 = icmp slt i64 %14, %17
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, i32* %i, align 4
  %18 = load i32* %i, align 4
  %conv19 = zext i32 %18 to i64
  %or = or i64 %conv19, -4503599627370496
  %or20 = or i64 %or, 281474976710656
  %19 = inttoptr i64 %or20 to i8*
  %o21 = bitcast %union.UnionType* %ret to i8**
  store i8* %19, i8** %o21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %do.body4
  %20 = load %union.UnionType** %a.addr, align 8
  %o23 = bitcast %union.UnionType* %20 to i8**
  %21 = load i8** %o23, align 8
  %22 = ptrtoint i8* %21 to i64
  %conv24 = sitofp i64 %22 to double
  %23 = load %union.UnionType** %b.addr, align 8
  %d25 = bitcast %union.UnionType* %23 to double*
  %24 = load double* %d25, align 8
  %cmp26 = fcmp olt double %conv24, %24
  %conv27 = zext i1 %cmp26 to i32
  %conv28 = sitofp i32 %conv27 to double
  store double %conv28, double* %d, align 8
  %25 = load double* %d, align 8
  %conv29 = fptosi double %25 to i32
  %conv30 = zext i32 %conv29 to i64
  %or31 = or i64 %conv30, -4503599627370496
  %or32 = or i64 %or31, 281474976710656
  %26 = inttoptr i64 %or32 to i8*
  %o33 = bitcast %union.UnionType* %ret to i8**
  store i8* %26, i8** %o33, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb22, %sw.bb14
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog72

sw.bb34:                                          ; preds = %do.body
  br label %do.body35

do.body35:                                        ; preds = %sw.bb34
  %27 = load %union.UnionType** %b.addr, align 8
  %o36 = bitcast %union.UnionType* %27 to i8**
  %28 = load i8** %o36, align 8
  %29 = ptrtoint i8* %28 to i64
  %and37 = and i64 %29, -4503599627370496
  %cmp38 = icmp eq i64 %and37, -4503599627370496
  %conv39 = zext i1 %cmp38 to i32
  %conv40 = sext i32 %conv39 to i64
  %30 = load %union.UnionType** %b.addr, align 8
  %o41 = bitcast %union.UnionType* %30 to i8**
  %31 = load i8** %o41, align 8
  %32 = ptrtoint i8* %31 to i64
  %and42 = and i64 %32, 4222124650659840
  %shr43 = lshr i64 %and42, 48
  %mul44 = mul i64 %conv40, %shr43
  switch i64 %mul44, label %sw.default68 [
    i64 1, label %sw.bb45
    i64 0, label %sw.bb56
  ]

sw.bb45:                                          ; preds = %do.body35
  %33 = load %union.UnionType** %a.addr, align 8
  %d47 = bitcast %union.UnionType* %33 to double*
  %34 = load double* %d47, align 8
  %35 = load %union.UnionType** %b.addr, align 8
  %o48 = bitcast %union.UnionType* %35 to i8**
  %36 = load i8** %o48, align 8
  %37 = ptrtoint i8* %36 to i64
  %conv49 = sitofp i64 %37 to double
  %cmp50 = fcmp olt double %34, %conv49
  %conv51 = zext i1 %cmp50 to i32
  store i32 %conv51, i32* %i46, align 4
  %38 = load i32* %i46, align 4
  %conv52 = zext i32 %38 to i64
  %or53 = or i64 %conv52, -4503599627370496
  %or54 = or i64 %or53, 281474976710656
  %39 = inttoptr i64 %or54 to i8*
  %o55 = bitcast %union.UnionType* %ret to i8**
  store i8* %39, i8** %o55, align 8
  br label %sw.epilog69

sw.bb56:                                          ; preds = %do.body35
  %40 = load %union.UnionType** %a.addr, align 8
  %d58 = bitcast %union.UnionType* %40 to double*
  %41 = load double* %d58, align 8
  %42 = load %union.UnionType** %b.addr, align 8
  %d59 = bitcast %union.UnionType* %42 to double*
  %43 = load double* %d59, align 8
  %cmp60 = fcmp olt double %41, %43
  %conv61 = zext i1 %cmp60 to i32
  %conv62 = sitofp i32 %conv61 to double
  store double %conv62, double* %d57, align 8
  %44 = load double* %d57, align 8
  %conv63 = fptosi double %44 to i32
  %conv64 = zext i32 %conv63 to i64
  %or65 = or i64 %conv64, -4503599627370496
  %or66 = or i64 %or65, 281474976710656
  %45 = inttoptr i64 %or66 to i8*
  %o67 = bitcast %union.UnionType* %ret to i8**
  store i8* %45, i8** %o67, align 8
  br label %sw.epilog69

sw.default68:                                     ; preds = %do.body35
  br label %sw.epilog69

sw.epilog69:                                      ; preds = %sw.default68, %sw.bb56, %sw.bb45
  br label %do.end70

do.end70:                                         ; preds = %sw.epilog69
  br label %sw.epilog72

sw.default71:                                     ; preds = %do.body
  br label %sw.epilog72

sw.epilog72:                                      ; preds = %sw.default71, %do.end70, %do.end
  br label %do.end73

do.end73:                                         ; preds = %sw.epilog72
  %46 = bitcast %union.UnionType* %retval to i8*
  %47 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %46, i8* %47, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %48 = bitcast double* %coerce.dive to i64*
  %49 = load i64* %48, align 1
  ret i64 %49
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_addInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %add = add nsw i32 %conv5, %9
  store i32 %add, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv6 = zext i32 %10 to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv10 = sitofp i32 %14 to double
  %add11 = fadd double %13, %conv10
  %d12 = bitcast %union.UnionType* %ret to double*
  store double %add11, double* %d12, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_subInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %sub = sub nsw i32 %conv5, %9
  store i32 %sub, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv6 = zext i32 %10 to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv10 = sitofp i32 %14 to double
  %sub11 = fsub double %13, %conv10
  %d12 = bitcast %union.UnionType* %ret to double*
  store double %sub11, double* %d12, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_mulInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb10
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %mul6 = mul nsw i32 %conv5, %9
  store i32 %mul6, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv7 = zext i32 %10 to i64
  %or = or i64 %conv7, -4503599627370496
  %or8 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or8 to i8*
  %o9 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o9, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv11 = sitofp i32 %14 to double
  %mul12 = fmul double %13, %conv11
  %d13 = bitcast %union.UnionType* %ret to double*
  store double %mul12, double* %d13, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb10, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_divInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %div = sdiv i32 %conv5, %9
  store i32 %div, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv6 = zext i32 %10 to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv10 = sitofp i32 %14 to double
  %div11 = fdiv double %13, %conv10
  %d12 = bitcast %union.UnionType* %ret to double*
  store double %div11, double* %d12, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_eqInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %cmp6 = icmp eq i32 %conv5, %9
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv13 = sitofp i32 %14 to double
  %cmp14 = fcmp oeq double %13, %conv13
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_neInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %cmp6 = icmp ne i32 %conv5, %9
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv13 = sitofp i32 %14 to double
  %cmp14 = fcmp une double %13, %conv13
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_gtInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %cmp6 = icmp sgt i32 %conv5, %9
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv13 = sitofp i32 %14 to double
  %cmp14 = fcmp ogt double %13, %conv13
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_ltInt(%union.UnionType* %a, i32 %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca i32, align 4
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %9 = load i32* %b.addr, align 4
  %cmp6 = icmp slt i32 %conv5, %9
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load i32* %b.addr, align 4
  %conv13 = sitofp i32 %14 to double
  %cmp14 = fcmp olt double %13, %conv13
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_addInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %add = add nsw i32 %6, %conv5
  store i32 %add, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv6 = zext i32 %10 to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv10 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %add11 = fadd double %conv10, %14
  %d12 = bitcast %union.UnionType* %ret to double*
  store double %add11, double* %d12, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_subInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %sub = sub nsw i32 %6, %conv5
  store i32 %sub, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv6 = zext i32 %10 to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv10 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %sub11 = fsub double %conv10, %14
  %d12 = bitcast %union.UnionType* %ret to double*
  store double %sub11, double* %d12, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_mulInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb10
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %mul6 = mul nsw i32 %6, %conv5
  store i32 %mul6, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv7 = zext i32 %10 to i64
  %or = or i64 %conv7, -4503599627370496
  %or8 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or8 to i8*
  %o9 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o9, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv11 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %mul12 = fmul double %conv11, %14
  %d13 = bitcast %union.UnionType* %ret to double*
  store double %mul12, double* %d13, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb10, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_divInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb9
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %div = sdiv i32 %6, %conv5
  store i32 %div, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv6 = zext i32 %10 to i64
  %or = or i64 %conv6, -4503599627370496
  %or7 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or7 to i8*
  %o8 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o8, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv10 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %div11 = fdiv double %conv10, %14
  %d12 = bitcast %union.UnionType* %ret to double*
  store double %div11, double* %d12, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %15 = bitcast %union.UnionType* %retval to i8*
  %16 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %17 = bitcast double* %coerce.dive to i64*
  %18 = load i64* %17, align 1
  ret i64 %18
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_eqInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %cmp6 = icmp eq i32 %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv13 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp14 = fcmp oeq double %conv13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_neInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %cmp6 = icmp ne i32 %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv13 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp14 = fcmp une double %conv13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_gtInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %cmp6 = icmp sgt i32 %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv13 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp14 = fcmp ogt double %conv13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_ltInt2(i32 %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load i32* %a.addr, align 4
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = trunc i64 %9 to i32
  %cmp6 = icmp slt i32 %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load i32* %a.addr, align 4
  %conv13 = sitofp i32 %12 to double
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp14 = fcmp olt double %conv13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_addDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb7
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %add = fadd double %conv6, %9
  %d = bitcast %union.UnionType* %ret to double*
  store double %add, double* %d, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %do.body
  %10 = load %union.UnionType** %a.addr, align 8
  %d8 = bitcast %union.UnionType* %10 to double*
  %11 = load double* %d8, align 8
  %12 = load double* %b.addr, align 8
  %add9 = fadd double %11, %12
  %d10 = bitcast %union.UnionType* %ret to double*
  store double %add9, double* %d10, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_subDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb7
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %sub = fsub double %conv6, %9
  %d = bitcast %union.UnionType* %ret to double*
  store double %sub, double* %d, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %do.body
  %10 = load %union.UnionType** %a.addr, align 8
  %d8 = bitcast %union.UnionType* %10 to double*
  %11 = load double* %d8, align 8
  %12 = load double* %b.addr, align 8
  %sub9 = fsub double %11, %12
  %d10 = bitcast %union.UnionType* %ret to double*
  store double %sub9, double* %d10, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_mulDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb8
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %mul7 = fmul double %conv6, %9
  %d = bitcast %union.UnionType* %ret to double*
  store double %mul7, double* %d, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %do.body
  %10 = load %union.UnionType** %a.addr, align 8
  %d9 = bitcast %union.UnionType* %10 to double*
  %11 = load double* %d9, align 8
  %12 = load double* %b.addr, align 8
  %mul10 = fmul double %11, %12
  %d11 = bitcast %union.UnionType* %ret to double*
  store double %mul10, double* %d11, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_divDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb7
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %div = fdiv double %conv6, %9
  %d = bitcast %union.UnionType* %ret to double*
  store double %div, double* %d, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %do.body
  %10 = load %union.UnionType** %a.addr, align 8
  %d8 = bitcast %union.UnionType* %10 to double*
  %11 = load double* %d8, align 8
  %12 = load double* %b.addr, align 8
  %div9 = fdiv double %11, %12
  %d10 = bitcast %union.UnionType* %ret to double*
  store double %div9, double* %d10, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_eqDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i13 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb12
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %cmp7 = fcmp oeq double %conv6, %9
  %conv8 = zext i1 %cmp7 to i32
  store i32 %conv8, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv9 = zext i32 %10 to i64
  %or = or i64 %conv9, -4503599627370496
  %or10 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or10 to i8*
  %o11 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o11, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load double* %b.addr, align 8
  %cmp14 = fcmp oeq double %13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i13, align 4
  %15 = load i32* %i13, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb12, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_neDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i13 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb12
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %cmp7 = fcmp une double %conv6, %9
  %conv8 = zext i1 %cmp7 to i32
  store i32 %conv8, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv9 = zext i32 %10 to i64
  %or = or i64 %conv9, -4503599627370496
  %or10 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or10 to i8*
  %o11 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o11, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load double* %b.addr, align 8
  %cmp14 = fcmp une double %13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i13, align 4
  %15 = load i32* %i13, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb12, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_gtDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i13 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb12
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %cmp7 = fcmp ogt double %conv6, %9
  %conv8 = zext i1 %cmp7 to i32
  store i32 %conv8, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv9 = zext i32 %10 to i64
  %or = or i64 %conv9, -4503599627370496
  %or10 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or10 to i8*
  %o11 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o11, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load double* %b.addr, align 8
  %cmp14 = fcmp ogt double %13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i13, align 4
  %15 = load i32* %i13, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb12, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_ltDouble(%union.UnionType* %a, double %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca %union.UnionType*, align 8
  %b.addr = alloca double, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i13 = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store double %b, double* %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb12
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %conv5 = trunc i64 %8 to i32
  %conv6 = sitofp i32 %conv5 to double
  %9 = load double* %b.addr, align 8
  %cmp7 = fcmp olt double %conv6, %9
  %conv8 = zext i1 %cmp7 to i32
  store i32 %conv8, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv9 = zext i32 %10 to i64
  %or = or i64 %conv9, -4503599627370496
  %or10 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or10 to i8*
  %o11 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o11, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.body
  %12 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %12 to double*
  %13 = load double* %d, align 8
  %14 = load double* %b.addr, align 8
  %cmp14 = fcmp olt double %13, %14
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %i13, align 4
  %15 = load i32* %i13, align 4
  %conv16 = zext i32 %15 to i64
  %or17 = or i64 %conv16, -4503599627370496
  %or18 = or i64 %or17, 281474976710656
  %16 = inttoptr i64 %or18 to i8*
  %o19 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o19, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb12, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_addDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %add = fadd double %6, %conv5
  %d = bitcast %union.UnionType* %ret to double*
  store double %add, double* %d, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %do.body
  %10 = load double* %a.addr, align 8
  %11 = load %union.UnionType** %b.addr, align 8
  %d7 = bitcast %union.UnionType* %11 to double*
  %12 = load double* %d7, align 8
  %add8 = fadd double %10, %12
  %d9 = bitcast %union.UnionType* %ret to double*
  store double %add8, double* %d9, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_subDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %add = fadd double %6, %conv5
  %d = bitcast %union.UnionType* %ret to double*
  store double %add, double* %d, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %do.body
  %10 = load double* %a.addr, align 8
  %11 = load %union.UnionType** %b.addr, align 8
  %d7 = bitcast %union.UnionType* %11 to double*
  %12 = load double* %d7, align 8
  %add8 = fadd double %10, %12
  %d9 = bitcast %union.UnionType* %ret to double*
  store double %add8, double* %d9, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_mulDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb7
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %mul6 = fmul double %6, %conv5
  %d = bitcast %union.UnionType* %ret to double*
  store double %mul6, double* %d, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %do.body
  %10 = load double* %a.addr, align 8
  %11 = load %union.UnionType** %b.addr, align 8
  %d8 = bitcast %union.UnionType* %11 to double*
  %12 = load double* %d8, align 8
  %mul9 = fmul double %10, %12
  %d10 = bitcast %union.UnionType* %ret to double*
  store double %mul9, double* %d10, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_divDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %div = fdiv double %6, %conv5
  %d = bitcast %union.UnionType* %ret to double*
  store double %div, double* %d, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %do.body
  %10 = load double* %a.addr, align 8
  %11 = load %union.UnionType** %b.addr, align 8
  %d7 = bitcast %union.UnionType* %11 to double*
  %12 = load double* %d7, align 8
  %div8 = fdiv double %10, %12
  %d9 = bitcast %union.UnionType* %ret to double*
  store double %div8, double* %d9, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %13 = bitcast %union.UnionType* %retval to i8*
  %14 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %15 = bitcast double* %coerce.dive to i64*
  %16 = load i64* %15, align 1
  ret i64 %16
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_eqDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %cmp6 = fcmp oeq double %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load double* %a.addr, align 8
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp13 = fcmp oeq double %12, %14
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv15 = zext i32 %15 to i64
  %or16 = or i64 %conv15, -4503599627370496
  %or17 = or i64 %or16, 281474976710656
  %16 = inttoptr i64 %or17 to i8*
  %o18 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o18, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_neDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %cmp6 = fcmp une double %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load double* %a.addr, align 8
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp13 = fcmp une double %12, %14
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv15 = zext i32 %15 to i64
  %or16 = or i64 %conv15, -4503599627370496
  %or17 = or i64 %or16, 281474976710656
  %16 = inttoptr i64 %or17 to i8*
  %o18 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o18, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_gtDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %cmp6 = fcmp ogt double %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load double* %a.addr, align 8
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp13 = fcmp ogt double %12, %14
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv15 = zext i32 %15 to i64
  %or16 = or i64 %conv15, -4503599627370496
  %or17 = or i64 %or16, 281474976710656
  %16 = inttoptr i64 %or17 to i8*
  %o18 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o18, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i64 @Object_ltDouble2(double %a, %union.UnionType* %b) #0 {
entry:
  %retval = alloca %union.UnionType, align 8
  %a.addr = alloca double, align 8
  %b.addr = alloca %union.UnionType*, align 8
  %ret = alloca %union.UnionType, align 8
  %i = alloca i32, align 4
  %i12 = alloca i32, align 4
  store double %a, double* %a.addr, align 8
  store %union.UnionType* %b, %union.UnionType** %b.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %union.UnionType** %b.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %b.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb11
  ]

sw.bb:                                            ; preds = %do.body
  %6 = load double* %a.addr, align 8
  %7 = load %union.UnionType** %b.addr, align 8
  %o4 = bitcast %union.UnionType* %7 to i8**
  %8 = load i8** %o4, align 8
  %9 = ptrtoint i8* %8 to i64
  %conv5 = sitofp i64 %9 to double
  %cmp6 = fcmp olt double %6, %conv5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %i, align 4
  %10 = load i32* %i, align 4
  %conv8 = zext i32 %10 to i64
  %or = or i64 %conv8, -4503599627370496
  %or9 = or i64 %or, 281474976710656
  %11 = inttoptr i64 %or9 to i8*
  %o10 = bitcast %union.UnionType* %ret to i8**
  store i8* %11, i8** %o10, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body
  %12 = load double* %a.addr, align 8
  %13 = load %union.UnionType** %b.addr, align 8
  %d = bitcast %union.UnionType* %13 to double*
  %14 = load double* %d, align 8
  %cmp13 = fcmp olt double %12, %14
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, i32* %i12, align 4
  %15 = load i32* %i12, align 4
  %conv15 = zext i32 %15 to i64
  %or16 = or i64 %conv15, -4503599627370496
  %or17 = or i64 %or16, 281474976710656
  %16 = inttoptr i64 %or17 to i8*
  %o18 = bitcast %union.UnionType* %ret to i8**
  store i8* %16, i8** %o18, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  %17 = bitcast %union.UnionType* %retval to i8*
  %18 = bitcast %union.UnionType* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %coerce.dive = getelementptr %union.UnionType* %retval, i32 0, i32 0
  %19 = bitcast double* %coerce.dive to i64*
  %20 = load i64* %19, align 1
  ret i64 %20
}

; Function Attrs: nounwind ssp uwtable
define i32 @Object_isTrue(i64 %a.coerce) #0 {
entry:
  %a = alloca %union.UnionType, align 8
  %ret = alloca i32, align 4
  %o = alloca i8*, align 8
  %coerce.dive = getelementptr %union.UnionType* %a, i32 0, i32 0
  %0 = bitcast double* %coerce.dive to i64*
  store i64 %a.coerce, i64* %0, align 1
  store i32 0, i32* %ret, align 4
  %o1 = bitcast %union.UnionType* %a to i8**
  %1 = load i8** %o1, align 8
  store i8* %1, i8** %o, align 8
  %2 = load i8** %o, align 8
  %3 = ptrtoint i8* %2 to i64
  %and = and i64 %3, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv2 = sext i32 %conv to i64
  %4 = load i8** %o, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv2, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %6 = load i8** %o, align 8
  %7 = ptrtoint i8* %6 to i64
  %cmp4 = icmp ne i64 %7, 0
  %conv5 = zext i1 %cmp4 to i32
  store i32 %conv5, i32* %ret, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %d = bitcast %union.UnionType* %a to double*
  %8 = load double* %d, align 8
  %cmp7 = fcmp une double %8, 0.000000e+00
  %conv8 = zext i1 %cmp7 to i32
  store i32 %conv8, i32* %ret, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb
  %9 = load i32* %ret, align 4
  ret i32 %9
}

; Function Attrs: nounwind ssp uwtable
define i32 @Value_isTrue(%union.UnionType* %a) #0 {
entry:
  %a.addr = alloca %union.UnionType*, align 8
  %ret = alloca i32, align 4
  store %union.UnionType* %a, %union.UnionType** %a.addr, align 8
  store i32 0, i32* %ret, align 4
  %0 = load %union.UnionType** %a.addr, align 8
  %o = bitcast %union.UnionType* %0 to i8**
  %1 = load i8** %o, align 8
  %2 = ptrtoint i8* %1 to i64
  %and = and i64 %2, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %3 = load %union.UnionType** %a.addr, align 8
  %o2 = bitcast %union.UnionType* %3 to i8**
  %4 = load i8** %o2, align 8
  %5 = ptrtoint i8* %4 to i64
  %and3 = and i64 %5, 4222124650659840
  %shr = lshr i64 %and3, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %union.UnionType** %a.addr, align 8
  %o4 = bitcast %union.UnionType* %6 to i8**
  %7 = load i8** %o4, align 8
  %8 = ptrtoint i8* %7 to i64
  %cmp5 = icmp ne i64 %8, 0
  %conv6 = zext i1 %cmp5 to i32
  store i32 %conv6, i32* %ret, align 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %9 = load %union.UnionType** %a.addr, align 8
  %d = bitcast %union.UnionType* %9 to double*
  %10 = load double* %d, align 8
  %cmp8 = fcmp une double %10, 0.000000e+00
  %conv9 = zext i1 %cmp8 to i32
  store i32 %conv9, i32* %ret, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb
  %11 = load i32* %ret, align 4
  ret i32 %11
}

attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { inlinehint nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noreturn }
