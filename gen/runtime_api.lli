; ModuleID = 'gen/runtime_api.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.7.0"

%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sbuf = type { i8*, i32 }
%struct.__sFILEX = type opaque
%struct._Array = type { i32, i8**, i64 }
%struct._Object = type { i32, i8* }

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str1 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str2 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str3 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@__func__.shift = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str4 = private unnamed_addr constant [18 x i8] c"gen/runtime_api.c\00", align 1
@.str5 = private unnamed_addr constant [21 x i8] c"0 && \22Type Error!\5Cn\22\00", align 1
@__stderrp = external global %struct.__sFILE*
@.str6 = private unnamed_addr constant [30 x i8] c"fetch from function argument\0A\00", align 1
@.str7 = private unnamed_addr constant [27 x i8] c"Type Error!: near by push\0A\00", align 1
@__func__.push = private unnamed_addr constant [5 x i8] c"push\00", align 1
@.str8 = private unnamed_addr constant [34 x i8] c"ERROR!!: cannot allocated memory\0A\00", align 1

; Function Attrs: nounwind ssp uwtable
define void @print_object(i8* %o) #0 {
entry:
  %o.addr = alloca i8*, align 8
  store i8* %o, i8** %o.addr, align 8
  %0 = load i8** %o.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %and = and i64 %1, -4503599627370496
  %cmp = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %2 = load i8** %o.addr, align 8
  %3 = ptrtoint i8* %2 to i64
  %and2 = and i64 %3, 4222124650659840
  %shr = lshr i64 %and2, 48
  %mul = mul i64 %conv1, %shr
  switch i64 %mul, label %sw.default [
    i64 1, label %sw.bb
    i64 0, label %sw.bb3
    i64 2, label %sw.bb5
    i64 3, label %sw.bb7
    i64 5, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry
  %4 = load i8** %o.addr, align 8
  %5 = ptrtoint i8* %4 to i64
  %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str, i32 0, i32 0), i64 %5)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %6 = load i8** %o.addr, align 8
  %7 = bitcast i8* %6 to double*
  %8 = load double* %7, align 8
  %call4 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), double %8)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %9 = load i8** %o.addr, align 8
  %10 = ptrtoint i8* %9 to i64
  %xor = xor i64 %10, -3940649673949184
  %11 = inttoptr i64 %xor to i8*
  %call6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str2, i32 0, i32 0), i8* %11)
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %12 = load i8** %o.addr, align 8
  %13 = ptrtoint i8* %12 to i64
  %xor8 = xor i64 %13, -3659174697238528
  %14 = inttoptr i64 %xor8 to %struct._Array*
  call void @print(%struct._Array* %14)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %15 = load i8** %o.addr, align 8
  %16 = ptrtoint i8* %15 to i64
  %xor10 = xor i64 %16, -3096224743817216
  %17 = inttoptr i64 %xor10 to %struct._Object*
  %18 = bitcast %struct._Object* %17 to i8*
  call void @print_object(i8* %18)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb7, %sw.bb5, %sw.bb3, %sw.bb
  ret void
}

declare i32 @printf(i8*, ...) #1

; Function Attrs: nounwind ssp uwtable
define void @print(%struct._Array* %array) #0 {
entry:
  %array.addr = alloca %struct._Array*, align 8
  %size = alloca i64, align 8
  %i = alloca i64, align 8
  store %struct._Array* %array, %struct._Array** %array.addr, align 8
  %0 = load %struct._Array** %array.addr, align 8
  %size1 = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size1, align 8
  store i64 %1, i64* %size, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64* %i, align 8
  %3 = load i64* %size, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64* %i, align 8
  %5 = load %struct._Array** %array.addr, align 8
  %list = getelementptr inbounds %struct._Array* %5, i32 0, i32 1
  %6 = load i8*** %list, align 8
  %arrayidx = getelementptr inbounds i8** %6, i64 %4
  %7 = load i8** %arrayidx, align 8
  call void @print_object(i8* %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i64* %i, align 8
  %inc = add i64 %8, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind ssp uwtable
define void @say(%struct._Array* %array) #0 {
entry:
  %array.addr = alloca %struct._Array*, align 8
  store %struct._Array* %array, %struct._Array** %array.addr, align 8
  %0 = load %struct._Array** %array.addr, align 8
  call void @print(%struct._Array* %0)
  %call = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind ssp uwtable
define %struct._Object* @shift(%struct._Array* %args) #0 {
entry:
  %retval = alloca %struct._Object*, align 8
  %args.addr = alloca %struct._Array*, align 8
  %ret = alloca %struct._Object*, align 8
  %size = alloca i64, align 8
  %o = alloca i8*, align 8
  %array = alloca %struct._Array*, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  store %struct._Object* null, %struct._Object** %ret, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %size1 = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size1, align 8
  store i64 %1, i64* %size, align 8
  %2 = load i64* %size, align 8
  %cmp = icmp ugt i64 %2, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._Object* null, %struct._Object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64* %size, align 8
  %cmp2 = icmp eq i64 %3, 1
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %4 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %4, i32 0, i32 1
  %5 = load i8*** %list, align 8
  %arrayidx = getelementptr inbounds i8** %5, i64 0
  %6 = load i8** %arrayidx, align 8
  store i8* %6, i8** %o, align 8
  br label %do.body

do.body:                                          ; preds = %if.then3
  %7 = load i8** %o, align 8
  %8 = ptrtoint i8* %7 to i64
  %and = and i64 %8, -4503599627370496
  %cmp4 = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp4 to i32
  %conv5 = sext i32 %conv to i64
  %9 = load i8** %o, align 8
  %10 = ptrtoint i8* %9 to i64
  %and6 = and i64 %10, 4222124650659840
  %shr = lshr i64 %and6, 48
  %mul = mul i64 %conv5, %shr
  %cmp7 = icmp ne i64 %mul, 3
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([6 x i8]* @__func__.shift, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str4, i32 0, i32 0), i32 48, i8* getelementptr inbounds ([21 x i8]* @.str5, i32 0, i32 0)) #6
  unreachable

if.end10:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end10
  %11 = load i8** %o, align 8
  %12 = ptrtoint i8* %11 to i64
  %xor = xor i64 %12, -3659174697238528
  %13 = inttoptr i64 %xor to %struct._Array*
  store %struct._Array* %13, %struct._Array** %array, align 8
  %14 = load %struct._Array** %array, align 8
  %list11 = getelementptr inbounds %struct._Array* %14, i32 0, i32 1
  %15 = load i8*** %list11, align 8
  %arrayidx12 = getelementptr inbounds i8** %15, i64 0
  %16 = load i8** %arrayidx12, align 8
  %17 = bitcast i8* %16 to %struct._Object*
  store %struct._Object* %17, %struct._Object** %ret, align 8
  %18 = load %struct._Array** %array, align 8
  %size13 = getelementptr inbounds %struct._Array* %18, i32 0, i32 2
  %19 = load i64* %size13, align 8
  %dec = add i64 %19, -1
  store i64 %dec, i64* %size13, align 8
  %20 = load %struct._Array** %array, align 8
  %list14 = getelementptr inbounds %struct._Array* %20, i32 0, i32 1
  %21 = load i8*** %list14, align 8
  %22 = bitcast i8** %21 to i8*
  %23 = call i64 @llvm.objectsize.i64(i8* %22, i1 false)
  %cmp15 = icmp ne i64 %23, -1
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %24 = load %struct._Array** %array, align 8
  %list17 = getelementptr inbounds %struct._Array* %24, i32 0, i32 1
  %25 = load i8*** %list17, align 8
  %26 = bitcast i8** %25 to i8*
  %27 = load %struct._Array** %array, align 8
  %list18 = getelementptr inbounds %struct._Array* %27, i32 0, i32 1
  %28 = load i8*** %list18, align 8
  %add.ptr = getelementptr inbounds i8** %28, i64 1
  %29 = bitcast i8** %add.ptr to i8*
  %30 = load %struct._Array** %array, align 8
  %size19 = getelementptr inbounds %struct._Array* %30, i32 0, i32 2
  %31 = load i64* %size19, align 8
  %mul20 = mul i64 %31, 8
  %32 = load %struct._Array** %array, align 8
  %list21 = getelementptr inbounds %struct._Array* %32, i32 0, i32 1
  %33 = load i8*** %list21, align 8
  %34 = bitcast i8** %33 to i8*
  %35 = call i64 @llvm.objectsize.i64(i8* %34, i1 false)
  %call = call i8* @__memmove_chk(i8* %26, i8* %29, i64 %mul20, i64 %35) #7
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %36 = load %struct._Array** %array, align 8
  %list22 = getelementptr inbounds %struct._Array* %36, i32 0, i32 1
  %37 = load i8*** %list22, align 8
  %38 = bitcast i8** %37 to i8*
  %39 = load %struct._Array** %array, align 8
  %list23 = getelementptr inbounds %struct._Array* %39, i32 0, i32 1
  %40 = load i8*** %list23, align 8
  %add.ptr24 = getelementptr inbounds i8** %40, i64 1
  %41 = bitcast i8** %add.ptr24 to i8*
  %42 = load %struct._Array** %array, align 8
  %size25 = getelementptr inbounds %struct._Array* %42, i32 0, i32 2
  %43 = load i64* %size25, align 8
  %mul26 = mul i64 %43, 8
  %call27 = call i8* @__inline_memmove_chk(i8* %38, i8* %41, i64 %mul26)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %call27, %cond.false ]
  br label %if.end29

if.else:                                          ; preds = %if.end
  %44 = load %struct.__sFILE** @__stderrp, align 8
  %call28 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %44, i8* getelementptr inbounds ([30 x i8]* @.str6, i32 0, i32 0))
  br label %if.end29

if.end29:                                         ; preds = %if.else, %cond.end
  %45 = load %struct._Object** %ret, align 8
  store %struct._Object* %45, %struct._Object** %retval
  br label %return

return:                                           ; preds = %if.end29, %if.then
  %46 = load %struct._Object** %retval
  ret %struct._Object* %46
}

; Function Attrs: noreturn
declare void @__assert_rtn(i8*, i8*, i32, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @llvm.objectsize.i64(i8*, i1) #3

; Function Attrs: nounwind
declare i8* @__memmove_chk(i8*, i8*, i64, i64) #4

; Function Attrs: inlinehint nounwind ssp uwtable
define internal i8* @__inline_memmove_chk(i8* %__dest, i8* %__src, i64 %__len) #5 {
entry:
  %__dest.addr = alloca i8*, align 8
  %__src.addr = alloca i8*, align 8
  %__len.addr = alloca i64, align 8
  store i8* %__dest, i8** %__dest.addr, align 8
  store i8* %__src, i8** %__src.addr, align 8
  store i64 %__len, i64* %__len.addr, align 8
  %0 = load i8** %__dest.addr, align 8
  %1 = load i8** %__src.addr, align 8
  %2 = load i64* %__len.addr, align 8
  %3 = load i8** %__dest.addr, align 8
  %4 = call i64 @llvm.objectsize.i64(i8* %3, i1 false)
  %call = call i8* @__memmove_chk(i8* %0, i8* %1, i64 %2, i64 %4) #7
  ret i8* %call
}

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: nounwind ssp uwtable
define i8* @push(%struct._Array* %args) #0 {
entry:
  %args.addr = alloca %struct._Array*, align 8
  %size = alloca i64, align 8
  %ret = alloca i8*, align 8
  %array = alloca i8*, align 8
  %value = alloca i8*, align 8
  %base = alloca %struct._Array*, align 8
  %tmp = alloca i8*, align 8
  store %struct._Array* %args, %struct._Array** %args.addr, align 8
  %0 = load %struct._Array** %args.addr, align 8
  %size1 = getelementptr inbounds %struct._Array* %0, i32 0, i32 2
  %1 = load i64* %size1, align 8
  store i64 %1, i64* %size, align 8
  store i8* null, i8** %ret, align 8
  %2 = load i64* %size, align 8
  %cmp = icmp ne i64 %2, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([27 x i8]* @.str7, i32 0, i32 0))
  br label %if.end35

if.else:                                          ; preds = %entry
  %4 = load %struct._Array** %args.addr, align 8
  %list = getelementptr inbounds %struct._Array* %4, i32 0, i32 1
  %5 = load i8*** %list, align 8
  %arrayidx = getelementptr inbounds i8** %5, i64 0
  %6 = load i8** %arrayidx, align 8
  store i8* %6, i8** %array, align 8
  %7 = load %struct._Array** %args.addr, align 8
  %list2 = getelementptr inbounds %struct._Array* %7, i32 0, i32 1
  %8 = load i8*** %list2, align 8
  %arrayidx3 = getelementptr inbounds i8** %8, i64 1
  %9 = load i8** %arrayidx3, align 8
  store i8* %9, i8** %value, align 8
  br label %do.body

do.body:                                          ; preds = %if.else
  %10 = load i8** %array, align 8
  %11 = ptrtoint i8* %10 to i64
  %and = and i64 %11, -4503599627370496
  %cmp4 = icmp eq i64 %and, -4503599627370496
  %conv = zext i1 %cmp4 to i32
  %conv5 = sext i32 %conv to i64
  %12 = load i8** %array, align 8
  %13 = ptrtoint i8* %12 to i64
  %and6 = and i64 %13, 4222124650659840
  %shr = lshr i64 %and6, 48
  %mul = mul i64 %conv5, %shr
  %cmp7 = icmp ne i64 %mul, 3
  br i1 %cmp7, label %if.then9, label %if.end

if.then9:                                         ; preds = %do.body
  call void @__assert_rtn(i8* getelementptr inbounds ([5 x i8]* @__func__.push, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8]* @.str4, i32 0, i32 0), i32 68, i8* getelementptr inbounds ([21 x i8]* @.str5, i32 0, i32 0)) #6
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %14 = load i8** %array, align 8
  %15 = ptrtoint i8* %14 to i64
  %xor = xor i64 %15, -3659174697238528
  %16 = inttoptr i64 %xor to %struct._Array*
  store %struct._Array* %16, %struct._Array** %base, align 8
  %17 = load %struct._Array** %base, align 8
  %size10 = getelementptr inbounds %struct._Array* %17, i32 0, i32 2
  %18 = load i64* %size10, align 8
  %add = add i64 %18, 1
  %mul11 = mul i64 8, %add
  %call12 = call i8* @malloc(i64 %mul11)
  store i8* %call12, i8** %tmp, align 8
  %tobool = icmp ne i8* %call12, null
  br i1 %tobool, label %if.else15, label %if.then13

if.then13:                                        ; preds = %do.end
  %19 = load %struct.__sFILE** @__stderrp, align 8
  %call14 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %19, i8* getelementptr inbounds ([34 x i8]* @.str8, i32 0, i32 0))
  br label %if.end34

if.else15:                                        ; preds = %do.end
  %20 = load i8** %tmp, align 8
  %21 = call i64 @llvm.objectsize.i64(i8* %20, i1 false)
  %cmp16 = icmp ne i64 %21, -1
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else15
  %22 = load i8** %tmp, align 8
  %23 = load %struct._Array** %base, align 8
  %list18 = getelementptr inbounds %struct._Array* %23, i32 0, i32 1
  %24 = load i8*** %list18, align 8
  %25 = bitcast i8** %24 to i8*
  %26 = load %struct._Array** %base, align 8
  %size19 = getelementptr inbounds %struct._Array* %26, i32 0, i32 2
  %27 = load i64* %size19, align 8
  %mul20 = mul i64 8, %27
  %28 = load i8** %tmp, align 8
  %29 = call i64 @llvm.objectsize.i64(i8* %28, i1 false)
  %call21 = call i8* @__memcpy_chk(i8* %22, i8* %25, i64 %mul20, i64 %29) #7
  br label %cond.end

cond.false:                                       ; preds = %if.else15
  %30 = load i8** %tmp, align 8
  %31 = load %struct._Array** %base, align 8
  %list22 = getelementptr inbounds %struct._Array* %31, i32 0, i32 1
  %32 = load i8*** %list22, align 8
  %33 = bitcast i8** %32 to i8*
  %34 = load %struct._Array** %base, align 8
  %size23 = getelementptr inbounds %struct._Array* %34, i32 0, i32 2
  %35 = load i64* %size23, align 8
  %mul24 = mul i64 8, %35
  %call25 = call i8* @__inline_memcpy_chk(i8* %30, i8* %33, i64 %mul24)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call21, %cond.true ], [ %call25, %cond.false ]
  %36 = load i8** %tmp, align 8
  %37 = bitcast i8* %36 to i8**
  %38 = load %struct._Array** %base, align 8
  %list26 = getelementptr inbounds %struct._Array* %38, i32 0, i32 1
  store i8** %37, i8*** %list26, align 8
  %39 = load i8** %value, align 8
  %40 = load %struct._Array** %base, align 8
  %size27 = getelementptr inbounds %struct._Array* %40, i32 0, i32 2
  %41 = load i64* %size27, align 8
  %42 = load %struct._Array** %base, align 8
  %list28 = getelementptr inbounds %struct._Array* %42, i32 0, i32 1
  %43 = load i8*** %list28, align 8
  %arrayidx29 = getelementptr inbounds i8** %43, i64 %41
  store i8* %39, i8** %arrayidx29, align 8
  %44 = load %struct._Array** %base, align 8
  %size30 = getelementptr inbounds %struct._Array* %44, i32 0, i32 2
  %45 = load i64* %size30, align 8
  %inc = add i64 %45, 1
  store i64 %inc, i64* %size30, align 8
  %46 = load %struct._Array** %base, align 8
  %size31 = getelementptr inbounds %struct._Array* %46, i32 0, i32 2
  %47 = load i64* %size31, align 8
  %and32 = and i64 %47, 4294967295
  %or = or i64 %and32, -4503599627370496
  %or33 = or i64 %or, 281474976710656
  %48 = inttoptr i64 %or33 to i8*
  store i8* %48, i8** %ret, align 8
  br label %if.end34

if.end34:                                         ; preds = %cond.end, %if.then13
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then
  %49 = load i8** %ret, align 8
  ret i8* %49
}

declare i8* @malloc(i64) #1

; Function Attrs: nounwind
declare i8* @__memcpy_chk(i8*, i8*, i64, i64) #4

; Function Attrs: inlinehint nounwind ssp uwtable
define internal i8* @__inline_memcpy_chk(i8* %__dest, i8* %__src, i64 %__len) #5 {
entry:
  %__dest.addr = alloca i8*, align 8
  %__src.addr = alloca i8*, align 8
  %__len.addr = alloca i64, align 8
  store i8* %__dest, i8** %__dest.addr, align 8
  store i8* %__src, i8** %__src.addr, align 8
  store i64 %__len, i64* %__len.addr, align 8
  %0 = load i8** %__dest.addr, align 8
  %1 = load i8** %__src.addr, align 8
  %2 = load i64* %__len.addr, align 8
  %3 = load i8** %__dest.addr, align 8
  %4 = call i64 @llvm.objectsize.i64(i8* %3, i1 false)
  %call = call i8* @__memcpy_chk(i8* %0, i8* %1, i64 %2, i64 %4) #7
  ret i8* %call
}

; Function Attrs: nounwind ssp uwtable
define %struct._Object* @new_Object() #0 {
entry:
  %call = call i8* @malloc(i64 16)
  %0 = bitcast i8* %call to %struct._Object*
  ret %struct._Object* %0
}

; Function Attrs: nounwind ssp uwtable
define i8* @Object_addObject(i8* %_a, i8* %_b) #0 {
entry:
  %_a.addr = alloca i8*, align 8
  %_b.addr = alloca i8*, align 8
  %a = alloca %struct._Object*, align 8
  %b = alloca %struct._Object*, align 8
  %ret = alloca i8*, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  %i14 = alloca i32, align 4
  %d22 = alloca double, align 8
  store i8* %_a, i8** %_a.addr, align 8
  store i8* %_b, i8** %_b.addr, align 8
  %0 = load i8** %_a.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %xor = xor i64 %1, -3096224743817216
  %2 = inttoptr i64 %xor to %struct._Object*
  store %struct._Object* %2, %struct._Object** %a, align 8
  %3 = load i8** %_b.addr, align 8
  %4 = ptrtoint i8* %3 to i64
  %xor1 = xor i64 %4, -3096224743817216
  %5 = inttoptr i64 %xor1 to %struct._Object*
  store %struct._Object* %5, %struct._Object** %b, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %6 = load %struct._Object** %a, align 8
  %type = getelementptr inbounds %struct._Object* %6, i32 0, i32 0
  %7 = load i32* %type, align 4
  switch i32 %7, label %sw.default27 [
    i32 1, label %sw.bb
    i32 0, label %sw.bb10
  ]

sw.bb:                                            ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %sw.bb
  %8 = load %struct._Object** %b, align 8
  %type3 = getelementptr inbounds %struct._Object* %8, i32 0, i32 0
  %9 = load i32* %type3, align 4
  switch i32 %9, label %sw.default [
    i32 1, label %sw.bb4
    i32 0, label %sw.bb7
  ]

sw.bb4:                                           ; preds = %do.body2
  %10 = load %struct._Object** %a, align 8
  %11 = ptrtoint %struct._Object* %10 to i64
  %12 = load %struct._Object** %b, align 8
  %13 = ptrtoint %struct._Object* %12 to i64
  %add = add nsw i64 %11, %13
  %conv = trunc i64 %add to i32
  store i32 %conv, i32* %i, align 4
  %14 = load i32* %i, align 4
  %conv5 = zext i32 %14 to i64
  %or = or i64 %conv5, -4503599627370496
  %or6 = or i64 %or, 281474976710656
  %15 = inttoptr i64 %or6 to i8*
  store i8* %15, i8** %ret, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %do.body2
  %16 = load %struct._Object** %a, align 8
  %17 = ptrtoint %struct._Object* %16 to i64
  %conv8 = sitofp i64 %17 to double
  %18 = load %struct._Object** %b, align 8
  %19 = bitcast %struct._Object* %18 to double*
  %20 = load double* %19, align 8
  %add9 = fadd double %conv8, %20
  store double %add9, double* %d, align 8
  %21 = bitcast double* %d to i8*
  store i8* %21, i8** %ret, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %do.body2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb4
  br label %do.end

do.end:                                           ; preds = %sw.epilog
  br label %sw.epilog28

sw.bb10:                                          ; preds = %do.body
  br label %do.body11

do.body11:                                        ; preds = %sw.bb10
  %22 = load %struct._Object** %b, align 8
  %type12 = getelementptr inbounds %struct._Object* %22, i32 0, i32 0
  %23 = load i32* %type12, align 4
  switch i32 %23, label %sw.default24 [
    i32 1, label %sw.bb13
    i32 0, label %sw.bb21
  ]

sw.bb13:                                          ; preds = %do.body11
  %24 = load %struct._Object** %a, align 8
  %25 = bitcast %struct._Object* %24 to double*
  %26 = load double* %25, align 8
  %27 = load %struct._Object** %b, align 8
  %28 = ptrtoint %struct._Object* %27 to i64
  %conv15 = sitofp i64 %28 to double
  %add16 = fadd double %26, %conv15
  %conv17 = fptosi double %add16 to i32
  store i32 %conv17, i32* %i14, align 4
  %29 = load i32* %i14, align 4
  %conv18 = zext i32 %29 to i64
  %or19 = or i64 %conv18, -4503599627370496
  %or20 = or i64 %or19, 281474976710656
  %30 = inttoptr i64 %or20 to i8*
  store i8* %30, i8** %ret, align 8
  br label %sw.epilog25

sw.bb21:                                          ; preds = %do.body11
  %31 = load %struct._Object** %a, align 8
  %32 = bitcast %struct._Object* %31 to double*
  %33 = load double* %32, align 8
  %34 = load %struct._Object** %b, align 8
  %35 = bitcast %struct._Object* %34 to double*
  %36 = load double* %35, align 8
  %add23 = fadd double %33, %36
  store double %add23, double* %d22, align 8
  %37 = bitcast double* %d22 to i8*
  store i8* %37, i8** %ret, align 8
  br label %sw.epilog25

sw.default24:                                     ; preds = %do.body11
  br label %sw.epilog25

sw.epilog25:                                      ; preds = %sw.default24, %sw.bb21, %sw.bb13
  br label %do.end26

do.end26:                                         ; preds = %sw.epilog25
  br label %sw.epilog28

sw.default27:                                     ; preds = %do.body
  br label %sw.epilog28

sw.epilog28:                                      ; preds = %sw.default27, %do.end26, %do.end
  br label %do.end29

do.end29:                                         ; preds = %sw.epilog28
  %38 = load i8** %ret, align 8
  ret i8* %38
}

attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone }
attributes #4 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { inlinehint nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn }
attributes #7 = { nounwind }
